
stk500boot.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000014  00800100  00007498  0000050c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000498  00007000  00007000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .debug_aranges 00000028  00000000  00000000  00000520  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 0000002a  00000000  00000000  00000548  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000038c  00000000  00000000  00000572  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00000142  00000000  00000000  000008fe  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   0000071c  00000000  00000000  00000a40  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000040  00000000  00000000  0000115c  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    00000174  00000000  00000000  0000119c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000075a  00000000  00000000  00001310  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubtypes 00000039  00000000  00000000  00001a6a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000098  00000000  00000000  00001aa3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__jumpMain>:
 * to reduce the code size, we need to provide our own initialization
 */
void __jumpMain     (void) __attribute__ ((naked)) __attribute__ ((section (".init9")));

void __jumpMain(void)
{    
    7000:	8f ef       	ldi	r24, 0xFF	; 255
    asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
    
    /* init stack here, bug WinAVR 20071221 does not init stack based on __stack */  
    asm volatile ("ldi r24,%0":: "M" (RAMEND & 0xFF));          
    asm volatile ("ldi r25,%0":: "M" (RAMEND >> 8));
    7002:	98 e0       	ldi	r25, 0x08	; 8
    asm volatile ("out __SP_H__,r25" ::);
    7004:	9e bf       	out	0x3e, r25	; 62
    asm volatile ("out __SP_L__,r24" ::);
    7006:	8d bf       	out	0x3d, r24	; 61
    
    asm volatile ( "clr __zero_reg__" );                       // GCC depends on register r1 set to 0
    7008:	11 24       	eor	r1, r1
    asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );  // set SREG to 0
    700a:	1f be       	out	0x3f, r1	; 63
#ifndef REMOVE_PROG_PIN_PULLUP	 
	PROG_PORT |= (1<<PROG_PIN);		                           // Enable internal pullup
    700c:	5a 9a       	sbi	0x0b, 2	; 11
#endif    
    asm volatile ( "rjmp main");                               // jump to main()
    700e:	0c c0       	rjmp	.+24     	; 0x7028 <main>

00007010 <sendchar>:
/*
 * send single byte to USART, wait until transmission is completed
 */
static void sendchar(char c)
{
    UART_DATA_REG = c;                                         // prepare transmission
    7010:	80 93 c6 00 	sts	0x00C6, r24
    while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));// wait until byte sent
    7014:	80 91 c0 00 	lds	r24, 0x00C0
    7018:	86 ff       	sbrs	r24, 6
    701a:	fc cf       	rjmp	.-8      	; 0x7014 <sendchar+0x4>
    UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);          // delete TXCflag
    701c:	80 91 c0 00 	lds	r24, 0x00C0
    7020:	80 64       	ori	r24, 0x40	; 64
    7022:	80 93 c0 00 	sts	0x00C0, r24
}
    7026:	08 95       	ret

00007028 <main>:
}


int main(void) __attribute__ ((OS_main));
int main(void)
{
    7028:	cd b7       	in	r28, 0x3d	; 61
    702a:	de b7       	in	r29, 0x3e	; 62
    702c:	c6 52       	subi	r28, 0x26	; 38
    702e:	d1 40       	sbci	r29, 0x01	; 1
    7030:	de bf       	out	0x3e, r29	; 62
    7032:	cd bf       	out	0x3d, r28	; 61


	/*
	 * Branch to bootloader or application code ?
	 */	
	if(!(PROG_IN & (1<<PROG_PIN)))  
    7034:	4a 99       	sbic	0x09, 2	; 9
    7036:	26 c2       	rjmp	.+1100   	; 0x7484 <main+0x45c>
        /*
         * Init UART
         * set baudrate and enable USART receiver and transmiter without interrupts 
         */     
  
        UART_BAUD_RATE_HIGH = 0;     
    7038:	10 92 c5 00 	sts	0x00C5, r1
        UART_BAUD_RATE_LOW = UART_BAUD_SELECT(BAUDRATE,F_CPU);
    703c:	83 e0       	ldi	r24, 0x03	; 3
    703e:	80 93 c4 00 	sts	0x00C4, r24
        UART_CONTROL_REG   = (1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER); 
    7042:	88 e1       	ldi	r24, 0x18	; 24
    7044:	80 93 c1 00 	sts	0x00C1, r24

int main(void) __attribute__ ((OS_main));
int main(void)
{
    address_t       address = 0;
    address_t       eraseAddress = 0;	
    7048:	66 24       	eor	r6, r6
    704a:	77 24       	eor	r7, r7


int main(void) __attribute__ ((OS_main));
int main(void)
{
    address_t       address = 0;
    704c:	ee 24       	eor	r14, r14
    704e:	ff 24       	eor	r15, r15
    address_t       eraseAddress = 0;	
	unsigned char   msgParseState;
    unsigned int    i = 0;
    unsigned char   checksum = 0;
    unsigned char   seqNum = 0;
    7050:	bb 24       	eor	r11, r11
{
    address_t       address = 0;
    address_t       eraseAddress = 0;	
	unsigned char   msgParseState;
    unsigned int    i = 0;
    unsigned char   checksum = 0;
    7052:	55 24       	eor	r5, r5
int main(void)
{
    address_t       address = 0;
    address_t       eraseAddress = 0;	
	unsigned char   msgParseState;
    unsigned int    i = 0;
    7054:	88 24       	eor	r8, r8
    7056:	99 24       	eor	r9, r9
				        msgParseState = ST_START;
				    }
				    break;
			    
			    case ST_GET_DATA:			        
				    msgBuffer[i++] = c;
    7058:	1e 01       	movw	r2, r28
    705a:	08 94       	sec
    705c:	21 1c       	adc	r2, r1
    705e:	31 1c       	adc	r3, r1
                        else
                            fuseBits = boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );                            
                    }
                    else 
                    {
                        fuseBits = boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
    7060:	59 e0       	ldi	r21, 0x09	; 9
    7062:	a5 2e       	mov	r10, r21
    7064:	0b c2       	rjmp	.+1046   	; 0x747c <main+0x454>
/*
 * Read single byte from USART, block if no data available
 */
static unsigned char recchar(void)
{
    while(!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)));  // wait for data
    7066:	90 91 c0 00 	lds	r25, 0x00C0
    706a:	97 ff       	sbrs	r25, 7
    706c:	fc cf       	rjmp	.-8      	; 0x7066 <main+0x3e>
    return UART_DATA_REG;
    706e:	40 91 c6 00 	lds	r20, 0x00C6
             */            
            msgParseState = ST_START;
	        while ( msgParseState != ST_PROCESS )
	        {
           		c = recchar();
                switch (msgParseState)
    7072:	83 30       	cpi	r24, 0x03	; 3
    7074:	f1 f0       	breq	.+60     	; 0x70b2 <main+0x8a>
    7076:	84 30       	cpi	r24, 0x04	; 4
    7078:	28 f4       	brcc	.+10     	; 0x7084 <main+0x5c>
    707a:	81 30       	cpi	r24, 0x01	; 1
    707c:	69 f0       	breq	.+26     	; 0x7098 <main+0x70>
    707e:	82 30       	cpi	r24, 0x02	; 2
    7080:	98 f4       	brcc	.+38     	; 0x70a8 <main+0x80>
    7082:	07 c0       	rjmp	.+14     	; 0x7092 <main+0x6a>
    7084:	85 30       	cpi	r24, 0x05	; 5
    7086:	19 f1       	breq	.+70     	; 0x70ce <main+0xa6>
    7088:	85 30       	cpi	r24, 0x05	; 5
    708a:	d0 f0       	brcs	.+52     	; 0x70c0 <main+0x98>
    708c:	86 30       	cpi	r24, 0x06	; 6
    708e:	59 f7       	brne	.-42     	; 0x7066 <main+0x3e>
    7090:	2a c0       	rjmp	.+84     	; 0x70e6 <main+0xbe>
                {
                case ST_START:
				    if( c == MESSAGE_START )
    7092:	4b 31       	cpi	r20, 0x1B	; 27
    7094:	99 f5       	brne	.+102    	; 0x70fc <main+0xd4>
    7096:	2a c0       	rjmp	.+84     	; 0x70ec <main+0xc4>
					    checksum = MESSAGE_START^0;
				    }
				    break;
				    
				case ST_GET_SEQ_NUM:
                    if ( (c == 1) || (c == seqNum) )
    7098:	41 30       	cpi	r20, 0x01	; 1
    709a:	11 f0       	breq	.+4      	; 0x70a0 <main+0x78>
    709c:	4b 15       	cp	r20, r11
    709e:	61 f5       	brne	.+88     	; 0x70f8 <main+0xd0>
                    {
				        seqNum = c;
				        msgParseState = ST_MSG_SIZE_1;
				        checksum ^= c;
    70a0:	54 26       	eor	r5, r20
 * Read single byte from USART, block if no data available
 */
static unsigned char recchar(void)
{
    while(!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)));  // wait for data
    return UART_DATA_REG;
    70a2:	b4 2e       	mov	r11, r20
				    
				case ST_GET_SEQ_NUM:
                    if ( (c == 1) || (c == seqNum) )
                    {
				        seqNum = c;
				        msgParseState = ST_MSG_SIZE_1;
    70a4:	82 e0       	ldi	r24, 0x02	; 2
				        checksum ^= c;
    70a6:	df cf       	rjmp	.-66     	; 0x7066 <main+0x3e>
                        msgParseState = ST_START;
                    }
			        break;
			        
			    case ST_MSG_SIZE_1:			    
				    msgLength = (unsigned int)c<<8;
    70a8:	34 2f       	mov	r19, r20
    70aa:	20 e0       	ldi	r18, 0x00	; 0
				    msgParseState = ST_MSG_SIZE_2;
				    checksum ^= c;
    70ac:	54 26       	eor	r5, r20
                    }
			        break;
			        
			    case ST_MSG_SIZE_1:			    
				    msgLength = (unsigned int)c<<8;
				    msgParseState = ST_MSG_SIZE_2;
    70ae:	83 e0       	ldi	r24, 0x03	; 3
				    checksum ^= c;
				    break;
    70b0:	da cf       	rjmp	.-76     	; 0x7066 <main+0x3e>
				    
			    case ST_MSG_SIZE_2:			
				    msgLength |= c;
    70b2:	84 2f       	mov	r24, r20
    70b4:	90 e0       	ldi	r25, 0x00	; 0
    70b6:	28 2b       	or	r18, r24
    70b8:	39 2b       	or	r19, r25
				    msgParseState = ST_GET_TOKEN;
				    checksum ^= c;
    70ba:	54 26       	eor	r5, r20
				    checksum ^= c;
				    break;
				    
			    case ST_MSG_SIZE_2:			
				    msgLength |= c;
				    msgParseState = ST_GET_TOKEN;
    70bc:	84 e0       	ldi	r24, 0x04	; 4
				    checksum ^= c;
				    break;
    70be:	d3 cf       	rjmp	.-90     	; 0x7066 <main+0x3e>
			    
			    case ST_GET_TOKEN:
			        if ( c == TOKEN )
    70c0:	4e 30       	cpi	r20, 0x0E	; 14
    70c2:	d1 f4       	brne	.+52     	; 0x70f8 <main+0xd0>
				    {
					    msgParseState = ST_GET_DATA;
					    checksum ^= c;
    70c4:	54 26       	eor	r5, r20
					    i = 0;
    70c6:	88 24       	eor	r8, r8
    70c8:	99 24       	eor	r9, r9
				    break;
			    
			    case ST_GET_TOKEN:
			        if ( c == TOKEN )
				    {
					    msgParseState = ST_GET_DATA;
    70ca:	85 e0       	ldi	r24, 0x05	; 5
    70cc:	cc cf       	rjmp	.-104    	; 0x7066 <main+0x3e>
				        msgParseState = ST_START;
				    }
				    break;
			    
			    case ST_GET_DATA:			        
				    msgBuffer[i++] = c;
    70ce:	f1 01       	movw	r30, r2
    70d0:	e8 0d       	add	r30, r8
    70d2:	f9 1d       	adc	r31, r9
    70d4:	40 83       	st	Z, r20
    70d6:	08 94       	sec
    70d8:	81 1c       	adc	r8, r1
    70da:	91 1c       	adc	r9, r1
				    checksum ^= c;
    70dc:	54 26       	eor	r5, r20
				    if ( i == msgLength )
    70de:	82 16       	cp	r8, r18
    70e0:	93 06       	cpc	r9, r19
    70e2:	09 f6       	brne	.-126    	; 0x7066 <main+0x3e>
    70e4:	07 c0       	rjmp	.+14     	; 0x70f4 <main+0xcc>
					    msgParseState = ST_GET_CHECK;
				    }
				    break;
						
			    case ST_GET_CHECK:
				    if( c == checksum )
    70e6:	45 15       	cp	r20, r5
    70e8:	39 f4       	brne	.+14     	; 0x70f8 <main+0xd0>
    70ea:	0b c0       	rjmp	.+22     	; 0x7102 <main+0xda>
                {
                case ST_START:
				    if( c == MESSAGE_START )
				    {
					    msgParseState = ST_GET_SEQ_NUM;
					    checksum = MESSAGE_START^0;
    70ec:	4b e1       	ldi	r20, 0x1B	; 27
    70ee:	54 2e       	mov	r5, r20
                switch (msgParseState)
                {
                case ST_START:
				    if( c == MESSAGE_START )
				    {
					    msgParseState = ST_GET_SEQ_NUM;
    70f0:	81 e0       	ldi	r24, 0x01	; 1
    70f2:	b9 cf       	rjmp	.-142    	; 0x7066 <main+0x3e>
			    case ST_GET_DATA:			        
				    msgBuffer[i++] = c;
				    checksum ^= c;
				    if ( i == msgLength )
				    {
					    msgParseState = ST_GET_CHECK;
    70f4:	86 e0       	ldi	r24, 0x06	; 6
    70f6:	b7 cf       	rjmp	.-146    	; 0x7066 <main+0x3e>
				    {
					    msgParseState = ST_PROCESS;					    
				    }
				    else
				    {
				        msgParseState = ST_START;
    70f8:	80 e0       	ldi	r24, 0x00	; 0
    70fa:	b5 cf       	rjmp	.-150    	; 0x7066 <main+0x3e>
        {   
            /*
             * Collect received bytes to a complete message
             */            
            msgParseState = ST_START;
	        while ( msgParseState != ST_PROCESS )
    70fc:	87 30       	cpi	r24, 0x07	; 7
    70fe:	09 f0       	breq	.+2      	; 0x7102 <main+0xda>
    7100:	b2 cf       	rjmp	.-156    	; 0x7066 <main+0x3e>
			
			/*
			 * Now process the STK500 commands, see Atmel Appnote AVR068
			 */
			
	        switch (msgBuffer[0])
    7102:	49 81       	ldd	r20, Y+1	; 0x01
    7104:	43 31       	cpi	r20, 0x13	; 19
    7106:	09 f4       	brne	.+2      	; 0x710a <main+0xe2>
    7108:	c3 c0       	rjmp	.+390    	; 0x7290 <main+0x268>
    710a:	44 31       	cpi	r20, 0x14	; 20
    710c:	c0 f4       	brcc	.+48     	; 0x713e <main+0x116>
    710e:	46 30       	cpi	r20, 0x06	; 6
    7110:	09 f4       	brne	.+2      	; 0x7114 <main+0xec>
    7112:	a5 c0       	rjmp	.+330    	; 0x725e <main+0x236>
    7114:	47 30       	cpi	r20, 0x07	; 7
    7116:	48 f4       	brcc	.+18     	; 0x712a <main+0x102>
    7118:	42 30       	cpi	r20, 0x02	; 2
    711a:	49 f1       	breq	.+82     	; 0x716e <main+0x146>
    711c:	43 30       	cpi	r20, 0x03	; 3
    711e:	09 f4       	brne	.+2      	; 0x7122 <main+0xfa>
    7120:	59 c0       	rjmp	.+178    	; 0x71d4 <main+0x1ac>
    7122:	41 30       	cpi	r20, 0x01	; 1
    7124:	09 f0       	breq	.+2      	; 0x7128 <main+0x100>
    7126:	64 c1       	rjmp	.+712    	; 0x73f0 <main+0x3c8>
    7128:	3e c0       	rjmp	.+124    	; 0x71a6 <main+0x17e>
    712a:	41 31       	cpi	r20, 0x11	; 17
    712c:	09 f4       	brne	.+2      	; 0x7130 <main+0x108>
    712e:	62 c0       	rjmp	.+196    	; 0x71f4 <main+0x1cc>
    7130:	42 31       	cpi	r20, 0x12	; 18
    7132:	08 f0       	brcs	.+2      	; 0x7136 <main+0x10e>
    7134:	8d c0       	rjmp	.+282    	; 0x7250 <main+0x228>
    7136:	40 31       	cpi	r20, 0x10	; 16
    7138:	09 f0       	breq	.+2      	; 0x713c <main+0x114>
    713a:	5a c1       	rjmp	.+692    	; 0x73f0 <main+0x3c8>
    713c:	18 c0       	rjmp	.+48     	; 0x716e <main+0x146>
    713e:	48 31       	cpi	r20, 0x18	; 24
    7140:	09 f4       	brne	.+2      	; 0x7144 <main+0x11c>
    7142:	72 c0       	rjmp	.+228    	; 0x7228 <main+0x200>
    7144:	49 31       	cpi	r20, 0x19	; 25
    7146:	50 f4       	brcc	.+20     	; 0x715c <main+0x134>
    7148:	45 31       	cpi	r20, 0x15	; 21
    714a:	09 f4       	brne	.+2      	; 0x714e <main+0x126>
    714c:	a1 c0       	rjmp	.+322    	; 0x7290 <main+0x268>
    714e:	45 31       	cpi	r20, 0x15	; 21
    7150:	08 f4       	brcc	.+2      	; 0x7154 <main+0x12c>
    7152:	09 c1       	rjmp	.+530    	; 0x7366 <main+0x33e>
    7154:	46 31       	cpi	r20, 0x16	; 22
    7156:	09 f0       	breq	.+2      	; 0x715a <main+0x132>
    7158:	4b c1       	rjmp	.+662    	; 0x73f0 <main+0x3c8>
    715a:	05 c1       	rjmp	.+522    	; 0x7366 <main+0x33e>
    715c:	4b 31       	cpi	r20, 0x1B	; 27
    715e:	09 f4       	brne	.+2      	; 0x7162 <main+0x13a>
    7160:	4c c0       	rjmp	.+152    	; 0x71fa <main+0x1d2>
    7162:	4d 31       	cpi	r20, 0x1D	; 29
    7164:	31 f0       	breq	.+12     	; 0x7172 <main+0x14a>
    7166:	4a 31       	cpi	r20, 0x1A	; 26
    7168:	09 f0       	breq	.+2      	; 0x716c <main+0x144>
    716a:	42 c1       	rjmp	.+644    	; 0x73f0 <main+0x3c8>
    716c:	51 c0       	rjmp	.+162    	; 0x7210 <main+0x1e8>
    716e:	90 e0       	ldi	r25, 0x00	; 0
    7170:	42 c0       	rjmp	.+132    	; 0x71f6 <main+0x1ce>
			case CMD_SPI_MULTI:
				{
	                unsigned char answerByte = 0;

                    // only Read Signature Bytes implemented, return dummy value for other instructions
					if ( msgBuffer[4]== 0x30 )
    7172:	9d 81       	ldd	r25, Y+5	; 0x05
    7174:	90 33       	cpi	r25, 0x30	; 48
    7176:	39 f4       	brne	.+14     	; 0x7186 <main+0x15e>
					{						
						unsigned char signatureIndex = msgBuffer[6];						
    7178:	8f 81       	ldd	r24, Y+7	; 0x07

						if ( signatureIndex == 0 )
    717a:	88 23       	and	r24, r24
    717c:	31 f0       	breq	.+12     	; 0x718a <main+0x162>
							answerByte = (SIGNATURE_BYTES >>16) & 0x000000FF;
						else if ( signatureIndex == 1 )
    717e:	81 30       	cpi	r24, 0x01	; 1
    7180:	31 f4       	brne	.+12     	; 0x718e <main+0x166>
							answerByte = (SIGNATURE_BYTES >> 8) & 0x000000FF;
    7182:	85 e9       	ldi	r24, 0x95	; 149
    7184:	05 c0       	rjmp	.+10     	; 0x7190 <main+0x168>
			
	        switch (msgBuffer[0])
	        {
			case CMD_SPI_MULTI:
				{
	                unsigned char answerByte = 0;
    7186:	80 e0       	ldi	r24, 0x00	; 0
    7188:	03 c0       	rjmp	.+6      	; 0x7190 <main+0x168>
					if ( msgBuffer[4]== 0x30 )
					{						
						unsigned char signatureIndex = msgBuffer[6];						

						if ( signatureIndex == 0 )
							answerByte = (SIGNATURE_BYTES >>16) & 0x000000FF;
    718a:	8e e1       	ldi	r24, 0x1E	; 30
    718c:	01 c0       	rjmp	.+2      	; 0x7190 <main+0x168>
						else if ( signatureIndex == 1 )
							answerByte = (SIGNATURE_BYTES >> 8) & 0x000000FF;
						else
							answerByte = SIGNATURE_BYTES & 0x000000FF;
    718e:	84 e1       	ldi	r24, 0x14	; 20
					}					
    				msgLength = 7;
					msgBuffer[1] = STATUS_CMD_OK;
    7190:	1a 82       	std	Y+2, r1	; 0x02
					msgBuffer[2] = 0;					
    7192:	1b 82       	std	Y+3, r1	; 0x03
					msgBuffer[3] = msgBuffer[4];  // Instruction Byte 1
    7194:	9c 83       	std	Y+4, r25	; 0x04
					msgBuffer[4] = msgBuffer[5];  // Instruction Byte 2
    7196:	9e 81       	ldd	r25, Y+6	; 0x06
    7198:	9d 83       	std	Y+5, r25	; 0x05
					msgBuffer[5] = answerByte;	                
    719a:	8e 83       	std	Y+6, r24	; 0x06
					msgBuffer[6] = STATUS_CMD_OK;
    719c:	1f 82       	std	Y+7, r1	; 0x07
				}
				break;
    719e:	90 e0       	ldi	r25, 0x00	; 0
						else if ( signatureIndex == 1 )
							answerByte = (SIGNATURE_BYTES >> 8) & 0x000000FF;
						else
							answerByte = SIGNATURE_BYTES & 0x000000FF;
					}					
    				msgLength = 7;
    71a0:	07 e0       	ldi	r16, 0x07	; 7
    71a2:	10 e0       	ldi	r17, 0x00	; 0
					msgBuffer[3] = msgBuffer[4];  // Instruction Byte 1
					msgBuffer[4] = msgBuffer[5];  // Instruction Byte 2
					msgBuffer[5] = answerByte;	                
					msgBuffer[6] = STATUS_CMD_OK;
				}
				break;
    71a4:	2a c1       	rjmp	.+596    	; 0x73fa <main+0x3d2>
            case CMD_SIGN_ON:
		        msgLength = 11;		        
		        msgBuffer[1]  = STATUS_CMD_OK;
    71a6:	1a 82       	std	Y+2, r1	; 0x02
		        msgBuffer[2]  = 8;
    71a8:	88 e0       	ldi	r24, 0x08	; 8
    71aa:	8b 83       	std	Y+3, r24	; 0x03
		        msgBuffer[3]  = 'A';
    71ac:	81 e4       	ldi	r24, 0x41	; 65
    71ae:	8c 83       	std	Y+4, r24	; 0x04
		        msgBuffer[4]  = 'V';
    71b0:	86 e5       	ldi	r24, 0x56	; 86
    71b2:	8d 83       	std	Y+5, r24	; 0x05
		        msgBuffer[5]  = 'R';
    71b4:	82 e5       	ldi	r24, 0x52	; 82
    71b6:	8e 83       	std	Y+6, r24	; 0x06
		        msgBuffer[6]  = 'I';
    71b8:	89 e4       	ldi	r24, 0x49	; 73
    71ba:	8f 83       	std	Y+7, r24	; 0x07
		        msgBuffer[7]  = 'S';
    71bc:	83 e5       	ldi	r24, 0x53	; 83
    71be:	88 87       	std	Y+8, r24	; 0x08
		        msgBuffer[8]  = 'P';
    71c0:	80 e5       	ldi	r24, 0x50	; 80
    71c2:	89 87       	std	Y+9, r24	; 0x09
		        msgBuffer[9]  = '_';
    71c4:	8f e5       	ldi	r24, 0x5F	; 95
    71c6:	8a 87       	std	Y+10, r24	; 0x0a
		        msgBuffer[10] = '2';
    71c8:	82 e3       	ldi	r24, 0x32	; 50
    71ca:	8b 87       	std	Y+11, r24	; 0x0b
		        break;
    71cc:	90 e0       	ldi	r25, 0x00	; 0
					msgBuffer[5] = answerByte;	                
					msgBuffer[6] = STATUS_CMD_OK;
				}
				break;
            case CMD_SIGN_ON:
		        msgLength = 11;		        
    71ce:	0b e0       	ldi	r16, 0x0B	; 11
    71d0:	10 e0       	ldi	r17, 0x00	; 0
		        msgBuffer[6]  = 'I';
		        msgBuffer[7]  = 'S';
		        msgBuffer[8]  = 'P';
		        msgBuffer[9]  = '_';
		        msgBuffer[10] = '2';
		        break;
    71d2:	13 c1       	rjmp	.+550    	; 0x73fa <main+0x3d2>
	        
	        case CMD_GET_PARAMETER:
	            {
	                unsigned char value;
	                
    		        switch(msgBuffer[1])
    71d4:	ea 81       	ldd	r30, Y+2	; 0x02
    71d6:	e0 58       	subi	r30, 0x80	; 128
    71d8:	e3 31       	cpi	r30, 0x13	; 19
    71da:	28 f4       	brcc	.+10     	; 0x71e6 <main+0x1be>
    71dc:	f0 e0       	ldi	r31, 0x00	; 0
    71de:	e0 50       	subi	r30, 0x00	; 0
    71e0:	ff 4f       	sbci	r31, 0xFF	; 255
    71e2:	80 81       	ld	r24, Z
    71e4:	01 c0       	rjmp	.+2      	; 0x71e8 <main+0x1c0>
    71e6:	80 e0       	ldi	r24, 0x00	; 0
    				default:
    				    value = 0;
    				    break;
    		        }
		            msgLength = 3;		        
		            msgBuffer[1] = STATUS_CMD_OK;
    71e8:	1a 82       	std	Y+2, r1	; 0x02
		            msgBuffer[2] = value;
    71ea:	8b 83       	std	Y+3, r24	; 0x03
		        }
	            break;
    71ec:	90 e0       	ldi	r25, 0x00	; 0
    				    break;				
    				default:
    				    value = 0;
    				    break;
    		        }
		            msgLength = 3;		        
    71ee:	03 e0       	ldi	r16, 0x03	; 3
    71f0:	10 e0       	ldi	r17, 0x00	; 0
		            msgBuffer[1] = STATUS_CMD_OK;
		            msgBuffer[2] = value;
		        }
	            break;
    71f2:	03 c1       	rjmp	.+518    	; 0x73fa <main+0x3d2>
	            
	        case CMD_LEAVE_PROGMODE_ISP:
	            isLeave = 1;
    71f4:	91 e0       	ldi	r25, 0x01	; 1
	        case CMD_ENTER_PROGMODE_ISP:    	            
	        case CMD_SET_PARAMETER:	        
		        msgLength = 2;		        
		        msgBuffer[1] = STATUS_CMD_OK;
    71f6:	1a 82       	std	Y+2, r1	; 0x02
    71f8:	fe c0       	rjmp	.+508    	; 0x73f6 <main+0x3ce>
                break;

            case CMD_READ_SIGNATURE_ISP:
                {
                    unsigned char signatureIndex = msgBuffer[4];
    71fa:	8d 81       	ldd	r24, Y+5	; 0x05
                    unsigned char signature;

                    if ( signatureIndex == 0 )
    71fc:	88 23       	and	r24, r24
    71fe:	21 f0       	breq	.+8      	; 0x7208 <main+0x1e0>
                        signature = (SIGNATURE_BYTES >>16) & 0x000000FF;
                    else if ( signatureIndex == 1 )
    7200:	81 30       	cpi	r24, 0x01	; 1
    7202:	21 f4       	brne	.+8      	; 0x720c <main+0x1e4>
                        signature = (SIGNATURE_BYTES >> 8) & 0x000000FF;
    7204:	85 e9       	ldi	r24, 0x95	; 149
    7206:	21 c0       	rjmp	.+66     	; 0x724a <main+0x222>
                {
                    unsigned char signatureIndex = msgBuffer[4];
                    unsigned char signature;

                    if ( signatureIndex == 0 )
                        signature = (SIGNATURE_BYTES >>16) & 0x000000FF;
    7208:	8e e1       	ldi	r24, 0x1E	; 30
    720a:	1f c0       	rjmp	.+62     	; 0x724a <main+0x222>
                    else if ( signatureIndex == 1 )
                        signature = (SIGNATURE_BYTES >> 8) & 0x000000FF;
                    else
                        signature = SIGNATURE_BYTES & 0x000000FF;
    720c:	84 e1       	ldi	r24, 0x14	; 20
    720e:	1d c0       	rjmp	.+58     	; 0x724a <main+0x222>
	            }
                break;

            case CMD_READ_LOCK_ISP:            
                msgLength = 4;
	            msgBuffer[1] = STATUS_CMD_OK;
    7210:	1a 82       	std	Y+2, r1	; 0x02
	            msgBuffer[2] = boot_lock_fuse_bits_get( GET_LOCK_BITS );
    7212:	e1 e0       	ldi	r30, 0x01	; 1
    7214:	f0 e0       	ldi	r31, 0x00	; 0
    7216:	a0 92 57 00 	sts	0x0057, r10
    721a:	e4 91       	lpm	r30, Z+
    721c:	eb 83       	std	Y+3, r30	; 0x03
	            msgBuffer[3] = STATUS_CMD_OK;	                                                
    721e:	1c 82       	std	Y+4, r1	; 0x04
                break;
    7220:	90 e0       	ldi	r25, 0x00	; 0
	                msgBuffer[3] = STATUS_CMD_OK;	                
	            }
                break;

            case CMD_READ_LOCK_ISP:            
                msgLength = 4;
    7222:	04 e0       	ldi	r16, 0x04	; 4
    7224:	10 e0       	ldi	r17, 0x00	; 0
	            msgBuffer[1] = STATUS_CMD_OK;
	            msgBuffer[2] = boot_lock_fuse_bits_get( GET_LOCK_BITS );
	            msgBuffer[3] = STATUS_CMD_OK;	                                                
                break;
    7226:	e9 c0       	rjmp	.+466    	; 0x73fa <main+0x3d2>
            
            case CMD_READ_FUSE_ISP:
                {                    
                    unsigned char fuseBits;                    
                    
                    if ( msgBuffer[2] == 0x50 )
    7228:	8b 81       	ldd	r24, Y+3	; 0x03
    722a:	80 35       	cpi	r24, 0x50	; 80
    722c:	49 f4       	brne	.+18     	; 0x7240 <main+0x218>
                    {
                        if ( msgBuffer[3] == 0x08 )
    722e:	8c 81       	ldd	r24, Y+4	; 0x04
    7230:	88 30       	cpi	r24, 0x08	; 8
    7232:	19 f4       	brne	.+6      	; 0x723a <main+0x212>
                            fuseBits = boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );                            
    7234:	e2 e0       	ldi	r30, 0x02	; 2
    7236:	f0 e0       	ldi	r31, 0x00	; 0
    7238:	05 c0       	rjmp	.+10     	; 0x7244 <main+0x21c>
                        else
                            fuseBits = boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );                            
    723a:	e0 e0       	ldi	r30, 0x00	; 0
    723c:	f0 e0       	ldi	r31, 0x00	; 0
    723e:	02 c0       	rjmp	.+4      	; 0x7244 <main+0x21c>
                    }
                    else 
                    {
                        fuseBits = boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
    7240:	e3 e0       	ldi	r30, 0x03	; 3
    7242:	f0 e0       	ldi	r31, 0x00	; 0
    7244:	a0 92 57 00 	sts	0x0057, r10
    7248:	84 91       	lpm	r24, Z+
                    }                    
                    msgLength = 4;    
	                msgBuffer[1] = STATUS_CMD_OK;
    724a:	1a 82       	std	Y+2, r1	; 0x02
	                msgBuffer[2] = fuseBits;	                
    724c:	8b 83       	std	Y+3, r24	; 0x03
    724e:	e7 cf       	rjmp	.-50     	; 0x721e <main+0x1f6>
                break;
                
            case CMD_CHIP_ERASE_ISP:
                eraseAddress = 0;
	            msgLength = 2;
	            msgBuffer[1] = STATUS_CMD_OK;
    7250:	1a 82       	std	Y+2, r1	; 0x02
                break;
    7252:	90 e0       	ldi	r25, 0x00	; 0
                }
                break;
                
            case CMD_CHIP_ERASE_ISP:
                eraseAddress = 0;
	            msgLength = 2;
    7254:	02 e0       	ldi	r16, 0x02	; 2
    7256:	10 e0       	ldi	r17, 0x00	; 0
	                msgBuffer[3] = STATUS_CMD_OK;	                                    
                }
                break;
                
            case CMD_CHIP_ERASE_ISP:
                eraseAddress = 0;
    7258:	66 24       	eor	r6, r6
    725a:	77 24       	eor	r7, r7
	            msgLength = 2;
	            msgBuffer[1] = STATUS_CMD_OK;
                break;
    725c:	ce c0       	rjmp	.+412    	; 0x73fa <main+0x3d2>

            case CMD_LOAD_ADDRESS:
#if defined(RAMPZ)
                address = ( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;
#else
		        address = ( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;  //convert word to byte address
    725e:	fc 81       	ldd	r31, Y+4	; 0x04
    7260:	c1 5e       	subi	r28, 0xE1	; 225
    7262:	de 4f       	sbci	r29, 0xFE	; 254
    7264:	f8 83       	st	Y, r31
    7266:	cf 51       	subi	r28, 0x1F	; 31
    7268:	d1 40       	sbci	r29, 0x01	; 1
    726a:	c2 5e       	subi	r28, 0xE2	; 226
    726c:	de 4f       	sbci	r29, 0xFE	; 254
    726e:	18 82       	st	Y, r1
    7270:	ce 51       	subi	r28, 0x1E	; 30
    7272:	d1 40       	sbci	r29, 0x01	; 1
    7274:	ed 80       	ldd	r14, Y+5	; 0x05
    7276:	ff 24       	eor	r15, r15
    7278:	c2 5e       	subi	r28, 0xE2	; 226
    727a:	de 4f       	sbci	r29, 0xFE	; 254
    727c:	28 81       	ld	r18, Y
    727e:	39 81       	ldd	r19, Y+1	; 0x01
    7280:	ce 51       	subi	r28, 0x1E	; 30
    7282:	d1 40       	sbci	r29, 0x01	; 1
    7284:	e2 2a       	or	r14, r18
    7286:	f3 2a       	or	r15, r19
    7288:	ee 0c       	add	r14, r14
    728a:	ff 1c       	adc	r15, r15
#endif
		        msgLength = 2;
		        msgBuffer[1] = STATUS_CMD_OK;
    728c:	1a 82       	std	Y+2, r1	; 0x02
    728e:	b2 c0       	rjmp	.+356    	; 0x73f4 <main+0x3cc>
                break;
                
            case CMD_PROGRAM_FLASH_ISP:
            case CMD_PROGRAM_EEPROM_ISP:                
                {
                    unsigned int  size = (((unsigned int)msgBuffer[1])<<8) | msgBuffer[2];
    7290:	3a 81       	ldd	r19, Y+2	; 0x02
    7292:	cf 5d       	subi	r28, 0xDF	; 223
    7294:	de 4f       	sbci	r29, 0xFE	; 254
    7296:	38 83       	st	Y, r19
    7298:	c1 52       	subi	r28, 0x21	; 33
    729a:	d1 40       	sbci	r29, 0x01	; 1
    729c:	c0 5e       	subi	r28, 0xE0	; 224
    729e:	de 4f       	sbci	r29, 0xFE	; 254
    72a0:	18 82       	st	Y, r1
    72a2:	c0 52       	subi	r28, 0x20	; 32
    72a4:	d1 40       	sbci	r29, 0x01	; 1
    72a6:	8b 81       	ldd	r24, Y+3	; 0x03
    72a8:	90 e0       	ldi	r25, 0x00	; 0
    72aa:	c0 5e       	subi	r28, 0xE0	; 224
    72ac:	de 4f       	sbci	r29, 0xFE	; 254
    72ae:	e8 81       	ld	r30, Y
    72b0:	f9 81       	ldd	r31, Y+1	; 0x01
    72b2:	c0 52       	subi	r28, 0x20	; 32
    72b4:	d1 40       	sbci	r29, 0x01	; 1
    72b6:	8e 2b       	or	r24, r30
    72b8:	9f 2b       	or	r25, r31
                    unsigned int  data;
                    unsigned char highByte, lowByte;                    
                    address_t     tempaddress = address;

                   
                    if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
    72ba:	43 31       	cpi	r20, 0x13	; 19
    72bc:	09 f0       	breq	.+2      	; 0x72c0 <main+0x298>
    72be:	3c c0       	rjmp	.+120    	; 0x7338 <main+0x310>
                    {
                		// erase only main section (bootloader protection)
                		if  (  eraseAddress < APP_END )
    72c0:	f0 e0       	ldi	r31, 0x00	; 0
    72c2:	6f 16       	cp	r6, r31
    72c4:	fc e7       	ldi	r31, 0x7C	; 124
    72c6:	7f 06       	cpc	r7, r31
    72c8:	60 f4       	brcc	.+24     	; 0x72e2 <main+0x2ba>
                		{
                			boot_page_erase(eraseAddress);	// Perform page erase
    72ca:	13 e0       	ldi	r17, 0x03	; 3
    72cc:	f3 01       	movw	r30, r6
    72ce:	10 93 57 00 	sts	0x0057, r17
    72d2:	e8 95       	spm
                			boot_spm_busy_wait();		// Wait until the memory is erased.
    72d4:	07 b6       	in	r0, 0x37	; 55
    72d6:	00 fc       	sbrc	r0, 0
    72d8:	fd cf       	rjmp	.-6      	; 0x72d4 <main+0x2ac>
                			eraseAddress += SPM_PAGESIZE;    // point to next page to be erase
    72da:	20 e8       	ldi	r18, 0x80	; 128
    72dc:	30 e0       	ldi	r19, 0x00	; 0
    72de:	62 0e       	add	r6, r18
    72e0:	73 1e       	adc	r7, r19
                    unsigned char fuseBits;                    
                    
                    if ( msgBuffer[2] == 0x50 )
                    {
                        if ( msgBuffer[3] == 0x08 )
                            fuseBits = boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );                            
    72e2:	97 01       	movw	r18, r14
                
            case CMD_PROGRAM_FLASH_ISP:
            case CMD_PROGRAM_EEPROM_ISP:                
                {
                    unsigned int  size = (((unsigned int)msgBuffer[1])<<8) | msgBuffer[2];
                    unsigned char *p = msgBuffer+10;
    72e4:	de 01       	movw	r26, r28
    72e6:	1b 96       	adiw	r26, 0x0b	; 11
                			eraseAddress += SPM_PAGESIZE;    // point to next page to be erase
                		}
                        
    		            /* Write FLASH */
        		        do {
        		            lowByte   = *p++;
    72e8:	4c 91       	ld	r20, X
        		            highByte  = *p++;
    72ea:	11 96       	adiw	r26, 0x01	; 1
    72ec:	5c 91       	ld	r21, X
    72ee:	11 97       	sbiw	r26, 0x01	; 1
    return UART_DATA_REG;
}


int main(void) __attribute__ ((OS_main));
int main(void)
    72f0:	12 96       	adiw	r26, 0x02	; 2
    		            /* Write FLASH */
        		        do {
        		            lowByte   = *p++;
        		            highByte  = *p++;
        				    
        				    data =  (highByte << 8) | lowByte;
    72f2:	75 2f       	mov	r23, r21
    72f4:	60 e0       	ldi	r22, 0x00	; 0
    72f6:	50 e0       	ldi	r21, 0x00	; 0
    72f8:	46 2b       	or	r20, r22
    72fa:	57 2b       	or	r21, r23
        				    boot_page_fill(address,data);
    72fc:	11 e0       	ldi	r17, 0x01	; 1
    72fe:	f9 01       	movw	r30, r18
    7300:	0a 01       	movw	r0, r20
    7302:	10 93 57 00 	sts	0x0057, r17
    7306:	e8 95       	spm
    7308:	11 24       	eor	r1, r1
        											
        				    address = address + 2;  	// Select next word in memory
    730a:	2e 5f       	subi	r18, 0xFE	; 254
    730c:	3f 4f       	sbci	r19, 0xFF	; 255
        				    size -= 2;			// Reduce number of bytes to write by two    
    730e:	02 97       	sbiw	r24, 0x02	; 2
        			    } while(size);			// Loop until all bytes written
    7310:	59 f7       	brne	.-42     	; 0x72e8 <main+0x2c0>
    7312:	cc 5d       	subi	r28, 0xDC	; 220
    7314:	de 4f       	sbci	r29, 0xFE	; 254
    7316:	79 83       	std	Y+1, r23	; 0x01
    7318:	68 83       	st	Y, r22
    731a:	c4 52       	subi	r28, 0x24	; 36
    731c:	d1 40       	sbci	r29, 0x01	; 1
        			    
            			boot_page_write(tempaddress);
    731e:	15 e0       	ldi	r17, 0x05	; 5
    7320:	f7 01       	movw	r30, r14
    7322:	10 93 57 00 	sts	0x0057, r17
    7326:	e8 95       	spm
        	    		boot_spm_busy_wait();	
    7328:	07 b6       	in	r0, 0x37	; 55
    732a:	00 fc       	sbrc	r0, 0
    732c:	fd cf       	rjmp	.-6      	; 0x7328 <main+0x300>
        		    	boot_rww_enable();				// Re-enable the RWW section                    
    732e:	81 e1       	ldi	r24, 0x11	; 17
    7330:	80 93 57 00 	sts	0x0057, r24
    7334:	e8 95       	spm
    7336:	14 c0       	rjmp	.+40     	; 0x7360 <main+0x338>
                    unsigned int  data;
                    unsigned char highByte, lowByte;                    
                    address_t     tempaddress = address;

                   
                    if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
    7338:	ac 01       	movw	r20, r24
    733a:	97 01       	movw	r18, r14
                
            case CMD_PROGRAM_FLASH_ISP:
            case CMD_PROGRAM_EEPROM_ISP:                
                {
                    unsigned int  size = (((unsigned int)msgBuffer[1])<<8) | msgBuffer[2];
                    unsigned char *p = msgBuffer+10;
    733c:	fe 01       	movw	r30, r28
    733e:	3b 96       	adiw	r30, 0x0b	; 11
    		        }
    		        else
    		        {
    		            /* write EEPROM */
        			    do {
        	 	            EEARL = address;			// Setup EEPROM address
    7340:	21 bd       	out	0x21, r18	; 33
        	                EEARH = (address >> 8);
    7342:	32 bd       	out	0x22, r19	; 34
        				    address++;					// Select next EEPROM byte
    7344:	2f 5f       	subi	r18, 0xFF	; 255
    7346:	3f 4f       	sbci	r19, 0xFF	; 255
        
        				    EEDR= *p++;				    // get byte from buffer
    7348:	61 91       	ld	r22, Z+
    734a:	60 bd       	out	0x20, r22	; 32
        	                EECR |= (1<<EEMWE);			// Write data into EEPROM
    734c:	fa 9a       	sbi	0x1f, 2	; 31
        	                EECR |= (1<<EEWE);
    734e:	f9 9a       	sbi	0x1f, 1	; 31
        	            
        				    while (EECR & (1<<EEWE));	// Wait for write operation to finish
    7350:	f9 99       	sbic	0x1f, 1	; 31
    7352:	fe cf       	rjmp	.-4      	; 0x7350 <main+0x328>
        				    size--;						// Decrease number of bytes to write
    7354:	41 50       	subi	r20, 0x01	; 1
    7356:	50 40       	sbci	r21, 0x00	; 0
        			    } while(size);					// Loop until all bytes written    		            
    7358:	99 f7       	brne	.-26     	; 0x7340 <main+0x318>
    735a:	97 01       	movw	r18, r14
    735c:	28 0f       	add	r18, r24
    735e:	39 1f       	adc	r19, r25
    		        }
           		    msgLength = 2;
		            msgBuffer[1] = STATUS_CMD_OK;    		        
    7360:	1a 82       	std	Y+2, r1	; 0x02
                }
                break;
    7362:	79 01       	movw	r14, r18
    7364:	47 c0       	rjmp	.+142    	; 0x73f4 <main+0x3cc>
                
            case CMD_READ_FLASH_ISP:
            case CMD_READ_EEPROM_ISP:                                                
                {
                    unsigned int  size = (((unsigned int)msgBuffer[1])<<8) | msgBuffer[2];
    7366:	9a 81       	ldd	r25, Y+2	; 0x02
    7368:	cd 5d       	subi	r28, 0xDD	; 221
    736a:	de 4f       	sbci	r29, 0xFE	; 254
    736c:	98 83       	st	Y, r25
    736e:	c3 52       	subi	r28, 0x23	; 35
    7370:	d1 40       	sbci	r29, 0x01	; 1
    7372:	ce 5d       	subi	r28, 0xDE	; 222
    7374:	de 4f       	sbci	r29, 0xFE	; 254
    7376:	18 82       	st	Y, r1
    7378:	c2 52       	subi	r28, 0x22	; 34
    737a:	d1 40       	sbci	r29, 0x01	; 1
    737c:	2b 81       	ldd	r18, Y+3	; 0x03
    737e:	30 e0       	ldi	r19, 0x00	; 0
    7380:	ce 5d       	subi	r28, 0xDE	; 222
    7382:	de 4f       	sbci	r29, 0xFE	; 254
    7384:	e8 81       	ld	r30, Y
    7386:	f9 81       	ldd	r31, Y+1	; 0x01
    7388:	c2 52       	subi	r28, 0x22	; 34
    738a:	d1 40       	sbci	r29, 0x01	; 1
    738c:	2e 2b       	or	r18, r30
    738e:	3f 2b       	or	r19, r31
                    unsigned char *p = msgBuffer+1;
                    msgLength = size+3;
    7390:	89 01       	movw	r16, r18
    7392:	0d 5f       	subi	r16, 0xFD	; 253
    7394:	1f 4f       	sbci	r17, 0xFF	; 255
                    
                    *p++ = STATUS_CMD_OK;                    
    7396:	1a 82       	std	Y+2, r1	; 0x02
                    if (msgBuffer[0] == CMD_READ_FLASH_ISP )
    7398:	44 31       	cpi	r20, 0x14	; 20
    739a:	89 f4       	brne	.+34     	; 0x73be <main+0x396>
                {
                    unsigned int  size = (((unsigned int)msgBuffer[1])<<8) | msgBuffer[2];
                    unsigned char *p = msgBuffer+1;
                    msgLength = size+3;
                    
                    *p++ = STATUS_CMD_OK;                    
    739c:	de 01       	movw	r26, r28
    739e:	13 96       	adiw	r26, 0x03	; 3
    73a0:	c7 01       	movw	r24, r14
                        // Read FLASH
                        do {                            
#if defined(RAMPZ)
                			data = pgm_read_word_far(address);
#else
        		        	data = pgm_read_word_near(address);
    73a2:	fc 01       	movw	r30, r24
    73a4:	45 91       	lpm	r20, Z+
    73a6:	54 91       	lpm	r21, Z+
#endif
        			        *p++ = (unsigned char)data;         //LSB
    73a8:	4c 93       	st	X, r20
        			        *p++ = (unsigned char)(data >> 8);	//MSB  
    73aa:	11 96       	adiw	r26, 0x01	; 1
    73ac:	5c 93       	st	X, r21
    73ae:	11 97       	sbiw	r26, 0x01	; 1
    return UART_DATA_REG;
}


int main(void) __attribute__ ((OS_main));
int main(void)
    73b0:	12 96       	adiw	r26, 0x02	; 2
#else
        		        	data = pgm_read_word_near(address);
#endif
        			        *p++ = (unsigned char)data;         //LSB
        			        *p++ = (unsigned char)(data >> 8);	//MSB  
        			        address    += 2;  	 // Select next word in memory
    73b2:	02 96       	adiw	r24, 0x02	; 2
        			        size -= 2;
    73b4:	22 50       	subi	r18, 0x02	; 2
    73b6:	30 40       	sbci	r19, 0x00	; 0
                        }while (size);
    73b8:	a1 f7       	brne	.-24     	; 0x73a2 <main+0x37a>
    73ba:	7c 01       	movw	r14, r24
    73bc:	16 c0       	rjmp	.+44     	; 0x73ea <main+0x3c2>
                {
                    unsigned int  size = (((unsigned int)msgBuffer[1])<<8) | msgBuffer[2];
                    unsigned char *p = msgBuffer+1;
                    msgLength = size+3;
                    
                    *p++ = STATUS_CMD_OK;                    
    73be:	ce 01       	movw	r24, r28
    73c0:	03 96       	adiw	r24, 0x03	; 3
    73c2:	e8 2f       	mov	r30, r24
    73c4:	69 2f       	mov	r22, r25
                    if (msgBuffer[0] == CMD_READ_FLASH_ISP )
    73c6:	c9 01       	movw	r24, r18
    73c8:	a7 01       	movw	r20, r14
                    }
                    else
                    {
          			    /* Read EEPROM */
        			    do {
        			        EEARL = address;			// Setup EEPROM address
    73ca:	41 bd       	out	0x21, r20	; 33
        			        EEARH = ((address >> 8));
    73cc:	52 bd       	out	0x22, r21	; 34
        			        address++;					// Select next EEPROM byte
    73ce:	4f 5f       	subi	r20, 0xFF	; 255
    73d0:	5f 4f       	sbci	r21, 0xFF	; 255
        			        EECR |= (1<<EERE);			// Read EEPROM
    73d2:	f8 9a       	sbi	0x1f, 0	; 31
        			        *p++ = EEDR;				// Send EEPROM data
    73d4:	70 b5       	in	r23, 0x20	; 32
    73d6:	ae 2f       	mov	r26, r30
    73d8:	b6 2f       	mov	r27, r22
    73da:	7d 93       	st	X+, r23
    73dc:	bd 01       	movw	r22, r26
    73de:	ea 2f       	mov	r30, r26
    73e0:	67 2f       	mov	r22, r23
        			        size--;    			        
    73e2:	01 97       	sbiw	r24, 0x01	; 1
        		        }while(size);
    73e4:	91 f7       	brne	.-28     	; 0x73ca <main+0x3a2>
    73e6:	e2 0e       	add	r14, r18
    73e8:	f3 1e       	adc	r15, r19
                    }
                    *p++ = STATUS_CMD_OK;
    73ea:	1c 92       	st	X, r1
                }
                break;
    73ec:	90 e0       	ldi	r25, 0x00	; 0
    73ee:	05 c0       	rjmp	.+10     	; 0x73fa <main+0x3d2>

	        default:
	            msgLength = 2;   
	            msgBuffer[1] = STATUS_CMD_FAILED;
    73f0:	f0 ec       	ldi	r31, 0xC0	; 192
    73f2:	fa 83       	std	Y+2, r31	; 0x02
	            break;
    73f4:	90 e0       	ldi	r25, 0x00	; 0
                    *p++ = STATUS_CMD_OK;
                }
                break;

	        default:
	            msgLength = 2;   
    73f6:	02 e0       	ldi	r16, 0x02	; 2
    73f8:	10 e0       	ldi	r17, 0x00	; 0
	        }

            /*
             * Now send answer message back
             */
	        sendchar(MESSAGE_START);     
    73fa:	8b e1       	ldi	r24, 0x1B	; 27
    73fc:	ca 5d       	subi	r28, 0xDA	; 218
    73fe:	de 4f       	sbci	r29, 0xFE	; 254
    7400:	98 83       	st	Y, r25
    7402:	c6 52       	subi	r28, 0x26	; 38
    7404:	d1 40       	sbci	r29, 0x01	; 1
    7406:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
	        checksum = MESSAGE_START^0;
	        
	        sendchar(seqNum);
    740a:	8b 2d       	mov	r24, r11
    740c:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
	        checksum ^= seqNum;
	        
	        c = ((msgLength>>8)&0xFF);
	        sendchar(c);
    7410:	81 2f       	mov	r24, r17
    7412:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
	        checksum ^= c;
	        
	        c = msgLength&0x00FF;
	        sendchar(c);
    7416:	80 2f       	mov	r24, r16
    7418:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
	        checksum ^= c;
	        
	        sendchar(TOKEN);
    741c:	8e e0       	ldi	r24, 0x0E	; 14
    741e:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
	        sendchar(seqNum);
	        checksum ^= seqNum;
	        
	        c = ((msgLength>>8)&0xFF);
	        sendchar(c);
	        checksum ^= c;
    7422:	85 e1       	ldi	r24, 0x15	; 21
    7424:	58 2e       	mov	r5, r24
    7426:	5b 24       	eor	r5, r11
	        
	        c = msgLength&0x00FF;
	        sendchar(c);
	        checksum ^= c;
    7428:	50 26       	eor	r5, r16
	        
	        sendchar(TOKEN);
	        checksum ^= TOKEN;
    742a:	51 26       	eor	r5, r17

            p = msgBuffer;
    742c:	61 01       	movw	r12, r2
    742e:	0e c0       	rjmp	.+28     	; 0x744c <main+0x424>
            while ( msgLength )
            {                
               c = *p++;
    7430:	f6 01       	movw	r30, r12
    7432:	41 90       	ld	r4, Z+
    7434:	6f 01       	movw	r12, r30
               sendchar(c);
    7436:	84 2d       	mov	r24, r4
    7438:	ca 5d       	subi	r28, 0xDA	; 218
    743a:	de 4f       	sbci	r29, 0xFE	; 254
    743c:	98 83       	st	Y, r25
    743e:	c6 52       	subi	r28, 0x26	; 38
    7440:	d1 40       	sbci	r29, 0x01	; 1
    7442:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
               checksum ^=c;
    7446:	54 24       	eor	r5, r4
               msgLength--;               
    7448:	01 50       	subi	r16, 0x01	; 1
    744a:	10 40       	sbci	r17, 0x00	; 0
    744c:	ca 5d       	subi	r28, 0xDA	; 218
    744e:	de 4f       	sbci	r29, 0xFE	; 254
    7450:	98 81       	ld	r25, Y
    7452:	c6 52       	subi	r28, 0x26	; 38
    7454:	d1 40       	sbci	r29, 0x01	; 1
	        
	        sendchar(TOKEN);
	        checksum ^= TOKEN;

            p = msgBuffer;
            while ( msgLength )
    7456:	01 15       	cp	r16, r1
    7458:	11 05       	cpc	r17, r1
    745a:	51 f7       	brne	.-44     	; 0x7430 <main+0x408>
               c = *p++;
               sendchar(c);
               checksum ^=c;
               msgLength--;               
            }                   
	        sendchar(checksum);	        
    745c:	85 2d       	mov	r24, r5
    745e:	ca 5d       	subi	r28, 0xDA	; 218
    7460:	de 4f       	sbci	r29, 0xFE	; 254
    7462:	98 83       	st	Y, r25
    7464:	c6 52       	subi	r28, 0x26	; 38
    7466:	d1 40       	sbci	r29, 0x01	; 1
    7468:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
        UART_BAUD_RATE_LOW = UART_BAUD_SELECT(BAUDRATE,F_CPU);
        UART_CONTROL_REG   = (1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER); 
        
        
        /* main loop */
        while(!isLeave)                             
    746c:	ca 5d       	subi	r28, 0xDA	; 218
    746e:	de 4f       	sbci	r29, 0xFE	; 254
    7470:	98 81       	ld	r25, Y
    7472:	c6 52       	subi	r28, 0x26	; 38
    7474:	d1 40       	sbci	r29, 0x01	; 1
    7476:	99 23       	and	r25, r25
    7478:	29 f4       	brne	.+10     	; 0x7484 <main+0x45c>
               sendchar(c);
               checksum ^=c;
               msgLength--;               
            }                   
	        sendchar(checksum);	        
	        seqNum++;
    747a:	b3 94       	inc	r11
}


int main(void) __attribute__ ((OS_main));
int main(void)
{
    747c:	80 e0       	ldi	r24, 0x00	; 0
    747e:	20 e0       	ldi	r18, 0x00	; 0
    7480:	30 e0       	ldi	r19, 0x00	; 0
    7482:	f1 cd       	rjmp	.-1054   	; 0x7066 <main+0x3e>
    
	/*
	 * Now leave bootloader
	 */
#ifndef REMOVE_PROG_PIN_PULLUP	
	PROG_PORT &= ~(1<<PROG_PIN);    // set to default
    7484:	5a 98       	cbi	0x0b, 2	; 11
#endif	
	boot_rww_enable();              // enable application section
    7486:	81 e1       	ldi	r24, 0x11	; 17
    7488:	80 93 57 00 	sts	0x0057, r24
    748c:	e8 95       	spm
	
	// Jump to Reset vector in Application Section
	// (clear register, push this register to the stack twice = adress 0x0000/words, and return to this address) 
    asm volatile ( 
    748e:	11 24       	eor	r1, r1
    7490:	1f 92       	push	r1
    7492:	1f 92       	push	r1
    7494:	08 95       	ret
    7496:	ff cf       	rjmp	.-2      	; 0x7496 <main+0x46e>
