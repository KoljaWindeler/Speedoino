   1               		.file	"stk500boot.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  11               	sendchar:
  12               	.LFB9:
  13               		.file 1 "stk500boot.c"
   1:stk500boot.c  **** 
   2:stk500boot.c  **** /*****************************************************************************
   3:stk500boot.c  **** Title:     STK500v2 compatible bootloader
   4:stk500boot.c  ****            Modified for Wiring board ATMega128-16MHz
   5:stk500boot.c  **** Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   6:stk500boot.c  **** File:      $Id: stk500boot.c,v 1.11 2006/06/25 12:39:17 peter Exp $
   7:stk500boot.c  **** Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   8:stk500boot.c  **** Hardware:  All AVRs with bootloader support, tested with ATmega8
   9:stk500boot.c  **** License:   GNU General Public License
  10:stk500boot.c  **** 
  11:stk500boot.c  **** Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  12:stk500boot.c  **** Date:      17 October 2007
  13:stk500boot.c  **** Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte re
  14:stk500boot.c  **** Compiler:  WINAVR20060421
  15:stk500boot.c  **** Description: add timeout feature like previous Wiring bootloader
  16:stk500boot.c  **** 
  17:stk500boot.c  **** DESCRIPTION:
  18:stk500boot.c  ****     This program allows an AVR with bootloader capabilities to
  19:stk500boot.c  ****     read/write its own Flash/EEprom. To enter Programming mode
  20:stk500boot.c  ****     an input pin is checked. If this pin is pulled low, programming mode
  21:stk500boot.c  ****     is entered. If not, normal execution is done from $0000
  22:stk500boot.c  ****     "reset" vector in Application area.
  23:stk500boot.c  ****     Size fits into a 1024 word bootloader section
  24:stk500boot.c  **** 	when compiled with avr-gcc 4.1
  25:stk500boot.c  **** 	(direct replace on Wiring Board without fuse setting changed)
  26:stk500boot.c  **** 
  27:stk500boot.c  **** USAGE:
  28:stk500boot.c  ****     - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  29:stk500boot.c  ****     - Set baud rate below (AVRISP only works with 115200 bps)
  30:stk500boot.c  ****     - compile/link the bootloader with the supplied Makefile
  31:stk500boot.c  ****     - program the "Boot Flash section size" (BOOTSZ fuses),
  32:stk500boot.c  ****       for boot-size 1024 words:  program BOOTSZ01
  33:stk500boot.c  ****     - enable the BOOT Reset Vector (program BOOTRST)
  34:stk500boot.c  ****     - Upload the hex file to the AVR using any ISP programmer
  35:stk500boot.c  ****     - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  36:stk500boot.c  ****     - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  37:stk500boot.c  ****     - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  38:stk500boot.c  ****     - AVRISP will detect the bootloader
  39:stk500boot.c  ****     - Program your application FLASH file and optional EEPROM file using AVRISP
  40:stk500boot.c  **** 
  41:stk500boot.c  **** Note:
  42:stk500boot.c  ****     Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  43:stk500boot.c  ****     is not implemented, due to AVRStudio limitations.
  44:stk500boot.c  ****     Flash is always erased before programming.
  45:stk500boot.c  **** 
  46:stk500boot.c  **** 	AVRdude:
  47:stk500boot.c  **** 	Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  48:stk500boot.c  **** 	Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  49:stk500boot.c  **** 	Read Fuse Bits and Read/Write Lock Bits is not supported
  50:stk500boot.c  **** 
  51:stk500boot.c  **** NOTES:
  52:stk500boot.c  ****     Based on Atmel Application Note AVR109 - Self-programming
  53:stk500boot.c  ****     Based on Atmel Application Note AVR068 - STK500v2 Protocol
  54:stk500boot.c  **** 
  55:stk500boot.c  **** LICENSE:
  56:stk500boot.c  ****     Copyright (C) 2006 Peter Fleury
  57:stk500boot.c  **** 
  58:stk500boot.c  ****     This program is free software; you can redistribute it and/or modify
  59:stk500boot.c  ****     it under the terms of the GNU General Public License as published by
  60:stk500boot.c  ****     the Free Software Foundation; either version 2 of the License, or
  61:stk500boot.c  ****     any later version.
  62:stk500boot.c  **** 
  63:stk500boot.c  ****     This program is distributed in the hope that it will be useful,
  64:stk500boot.c  ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  65:stk500boot.c  ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  66:stk500boot.c  ****     GNU General Public License for more details.
  67:stk500boot.c  **** 
  68:stk500boot.c  ****  *****************************************************************************/
  69:stk500boot.c  **** 
  70:stk500boot.c  **** //************************************************************************
  71:stk500boot.c  **** //*	Edit History
  72:stk500boot.c  **** //************************************************************************
  73:stk500boot.c  **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  74:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  75:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  76:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  77:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Adding monitor code
  78:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  79:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  80:stk500boot.c  **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  81:stk500boot.c  **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  82:stk500boot.c  **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  83:stk500boot.c  **** //************************************************************************
  84:stk500boot.c  **** 
  85:stk500boot.c  **** 
  86:stk500boot.c  **** 
  87:stk500boot.c  **** #include	<inttypes.h>
  88:stk500boot.c  **** #include	<avr/io.h>
  89:stk500boot.c  **** #include	<avr/interrupt.h>
  90:stk500boot.c  **** #include	<avr/boot.h>
  91:stk500boot.c  **** #include	<avr/pgmspace.h>
  92:stk500boot.c  **** #include	<util/delay.h>
  93:stk500boot.c  **** #include	<avr/eeprom.h>
  94:stk500boot.c  **** #include	<avr/common.h>
  95:stk500boot.c  **** #include	<stdlib.h>
  96:stk500boot.c  **** #include	"command.h"
  97:stk500boot.c  **** #include	"display.h"
  98:stk500boot.c  **** #include   "logo.h"
  99:stk500boot.c  **** 
 100:stk500boot.c  **** 
 101:stk500boot.c  **** #ifndef EEWE
 102:stk500boot.c  **** #define EEWE 1
 103:stk500boot.c  **** #endif
 104:stk500boot.c  **** #ifndef EEMWE
 105:stk500boot.c  **** #define EEMWE 2
 106:stk500boot.c  **** #endif
 107:stk500boot.c  **** 
 108:stk500boot.c  **** //#define	_DEBUG_SERIAL_
 109:stk500boot.c  **** 
 110:stk500boot.c  **** /*
 111:stk500boot.c  ****  * Uncomment the following lines to save code space
 112:stk500boot.c  ****  */
 113:stk500boot.c  **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 114:stk500boot.c  **** //
 115:stk500boot.c  **** 
 116:stk500boot.c  **** /*
 117:stk500boot.c  ****  * define CPU frequency in Mhz here if not defined in Makefile
 118:stk500boot.c  ****  */
 119:stk500boot.c  **** #ifndef F_CPU
 120:stk500boot.c  **** #define F_CPU 16000000UL
 121:stk500boot.c  **** #endif
 122:stk500boot.c  **** 
 123:stk500boot.c  **** /*
 124:stk500boot.c  ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 125:stk500boot.c  ****  */
 126:stk500boot.c  **** 
 127:stk500boot.c  **** #ifndef BAUDRATE
 128:stk500boot.c  **** #define BAUDRATE 115200
 129:stk500boot.c  **** #endif
 130:stk500boot.c  **** 
 131:stk500boot.c  **** /*
 132:stk500boot.c  ****  *  Enable (1) or disable (0) USART double speed operation
 133:stk500boot.c  ****  */
 134:stk500boot.c  **** #define UART_BAUDRATE_DOUBLE_SPEED 1
 135:stk500boot.c  **** /*
 136:stk500boot.c  ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 137:stk500boot.c  ****  */
 138:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 139:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 140:stk500boot.c  **** #define CONFIG_PARAM_HW_VER				0x0F
 141:stk500boot.c  **** #define CONFIG_PARAM_SW_MAJOR			2
 142:stk500boot.c  **** #define CONFIG_PARAM_SW_MINOR			0x0A
 143:stk500boot.c  **** 
 144:stk500boot.c  **** /*
 145:stk500boot.c  ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 146:stk500boot.c  ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 147:stk500boot.c  ****  */
 148:stk500boot.c  **** //#define BOOTSIZE 1024
 149:stk500boot.c  **** #if FLASHEND > 0x0F000
 150:stk500boot.c  **** #define BOOTSIZE 8192
 151:stk500boot.c  **** #else
 152:stk500boot.c  **** #define BOOTSIZE 2048
 153:stk500boot.c  **** #endif
 154:stk500boot.c  **** 
 155:stk500boot.c  **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 156:stk500boot.c  **** 
 157:stk500boot.c  **** /*
 158:stk500boot.c  ****  * Signature bytes are not available in avr-gcc io_xxx.h
 159:stk500boot.c  ****  */
 160:stk500boot.c  **** #define SIGNATURE_BYTES 0x1E9801
 161:stk500boot.c  **** 
 162:stk500boot.c  **** 
 163:stk500boot.c  **** /* ATMega with two USART, use UART0 */
 164:stk500boot.c  **** #define	UART_BAUD_RATE_LOW			UBRR0L
 165:stk500boot.c  **** #define	UART_STATUS_REG				UCSR0A
 166:stk500boot.c  **** #define	UART_CONTROL_REG			UCSR0B
 167:stk500boot.c  **** #define	UART_ENABLE_TRANSMITTER		TXEN0
 168:stk500boot.c  **** #define	UART_ENABLE_RECEIVER		RXEN0
 169:stk500boot.c  **** #define	UART_TRANSMIT_COMPLETE		TXC0
 170:stk500boot.c  **** #define	UART_RECEIVE_COMPLETE		RXC0
 171:stk500boot.c  **** #define	UART_DATA_REG				UDR0
 172:stk500boot.c  **** #define	UART_DOUBLE_SPEED			U2X0
 173:stk500boot.c  **** 
 174:stk500boot.c  **** 
 175:stk500boot.c  **** 
 176:stk500boot.c  **** /*
 177:stk500boot.c  ****  * Macro to calculate UBBR from XTAL and baudrate
 178:stk500boot.c  ****  */
 179:stk500boot.c  **** #define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
 180:stk500boot.c  **** 
 181:stk500boot.c  **** 
 182:stk500boot.c  **** /*
 183:stk500boot.c  ****  * States used in the receive state machine
 184:stk500boot.c  ****  */
 185:stk500boot.c  **** #define	ST_START		0
 186:stk500boot.c  **** #define	ST_GET_SEQ_NUM	1
 187:stk500boot.c  **** #define ST_MSG_SIZE_1	2
 188:stk500boot.c  **** #define ST_MSG_SIZE_2	3
 189:stk500boot.c  **** #define ST_GET_TOKEN	4
 190:stk500boot.c  **** #define ST_GET_DATA		5
 191:stk500boot.c  **** #define	ST_GET_CHECK	6
 192:stk500boot.c  **** #define	ST_PROCESS		7
 193:stk500boot.c  **** 
 194:stk500boot.c  **** /*
 195:stk500boot.c  ****  * use 16bit address variable for ATmegas with <= 64K flash
 196:stk500boot.c  ****  */
 197:stk500boot.c  **** #if defined(RAMPZ)
 198:stk500boot.c  **** typedef uint32_t address_t;
 199:stk500boot.c  **** #else
 200:stk500boot.c  **** typedef uint16_t address_t;
 201:stk500boot.c  **** #endif
 202:stk500boot.c  **** 
 203:stk500boot.c  **** /*
 204:stk500boot.c  ****  * function prototypes
 205:stk500boot.c  ****  */
 206:stk500boot.c  **** static void sendchar(char c);
 207:stk500boot.c  **** 
 208:stk500boot.c  **** /*
 209:stk500boot.c  ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 210:stk500boot.c  ****  * to reduce the code size, we need to provide our own initialization
 211:stk500boot.c  ****  */
 212:stk500boot.c  **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 213:stk500boot.c  **** #include <avr/sfr_defs.h>
 214:stk500boot.c  **** 
 215:stk500boot.c  **** //#define	SPH_REG	0x3E
 216:stk500boot.c  **** //#define	SPL_REG	0x3D
 217:stk500boot.c  **** 
 218:stk500boot.c  **** //*****************************************************************************
 219:stk500boot.c  **** void __jumpMain(void)
 220:stk500boot.c  **** {
 221:stk500boot.c  **** 	//*	July 17, 2010	<MLS> Added stack pointer initialzation
 222:stk500boot.c  **** 	//*	the first line did not do the job on the ATmega128
 223:stk500boot.c  **** 
 224:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 225:stk500boot.c  **** 
 226:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 227:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 228:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 229:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 230:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
 231:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 232:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 233:stk500boot.c  **** }
 234:stk500boot.c  **** 
 235:stk500boot.c  **** 
 236:stk500boot.c  **** //*****************************************************************************
 237:stk500boot.c  **** void delay_ms(unsigned int timedelay)
 238:stk500boot.c  **** {
 239:stk500boot.c  **** 	unsigned int i;
 240:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 241:stk500boot.c  **** 	{
 242:stk500boot.c  **** 		_delay_ms(0.5);
 243:stk500boot.c  **** 	}
 244:stk500boot.c  **** }
 245:stk500boot.c  **** 
 246:stk500boot.c  **** //*****************************************************************************
 247:stk500boot.c  **** /*
 248:stk500boot.c  ****  * send single byte to USART, wait until transmission is completed
 249:stk500boot.c  ****  */
 250:stk500boot.c  **** static void sendchar(char c)
 251:stk500boot.c  **** {
  14               		.loc 1 251 0
  15               	.LVL0:
  16               	/* prologue: function */
  17               	/* frame size = 0 */
  18               	/* stack size = 0 */
  19               	.L__stack_usage = 0
 252:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
  20               		.loc 1 252 0
  21 0000 8093 C600 		sts 198,r24
  22               	.LVL1:
  23               	.L2:
 253:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));	// wait until byte sent
  24               		.loc 1 253 0 discriminator 1
  25 0004 8091 C000 		lds r24,192
  26 0008 86FF      		sbrs r24,6
  27 000a 00C0      		rjmp .L2
 254:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);			// delete TXCflag
  28               		.loc 1 254 0
  29 000c 8091 C000 		lds r24,192
  30 0010 8064      		ori r24,lo8(64)
  31 0012 8093 C000 		sts 192,r24
  32 0016 0895      		ret
  33               	.LFE9:
  36               	senden_spi:
  37               	.LFB11:
 255:stk500boot.c  **** }
 256:stk500boot.c  **** 
 257:stk500boot.c  **** 
 258:stk500boot.c  **** //************************************************************************
 259:stk500boot.c  **** static int	Serial_Available(void)
 260:stk500boot.c  **** {
 261:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 262:stk500boot.c  **** }
 263:stk500boot.c  **** 
 264:stk500boot.c  **** //************************************************************************
 265:stk500boot.c  **** // basic display functions
 266:stk500boot.c  **** static void senden_spi(unsigned char zeichen){
  38               		.loc 1 266 0
  39               	.LVL2:
  40               	/* prologue: function */
  41               	/* frame size = 0 */
  42               	/* stack size = 0 */
  43               	.L__stack_usage = 0
 267:stk500boot.c  **** 	unsigned char a=0, b=0b10000000;
 268:stk500boot.c  **** 	fastWriteLow(SPI_CS); // cs auf low => aktivieren
  44               		.loc 1 268 0
  45 0018 4398      		cbi 0x8,3
 269:stk500boot.c  **** 	fastWriteHigh(SPI_CLK); // clock auf high, zu fallender flanke werden daten �bernommen
  46               		.loc 1 269 0
  47 001a 429A      		sbi 0x8,2
  48 001c 98E0      		ldi r25,lo8(8)
 267:stk500boot.c  **** 	unsigned char a=0, b=0b10000000;
  49               		.loc 1 267 0
  50 001e 20E8      		ldi r18,lo8(-128)
  51               	.LVL3:
  52               	.L10:
 270:stk500boot.c  **** 
 271:stk500boot.c  **** 	for(a=0;a<8;a++){ /* a = 0..7, wegen 8 pixel zeichen breite */
 272:stk500boot.c  **** 		if(zeichen&b)	
  53               		.loc 1 272 0
  54 0020 322F      		mov r19,r18
  55 0022 3823      		and r19,r24
  56 0024 01F0      		breq .L8
 273:stk500boot.c  **** 			fastWriteHigh(SPI_DATA); /* wenn zeichen&b dann porta bit 0 auf high serial data line */
  57               		.loc 1 273 0
  58 0026 419A      		sbi 0x8,1
  59 0028 00C0      		rjmp .L9
  60               	.L8:
 274:stk500boot.c  **** 		else 
 275:stk500boot.c  **** 			fastWriteLow(SPI_DATA); /* PORTA bit 0 auf low zwingen serial data line */
  61               		.loc 1 275 0
  62 002a 4198      		cbi 0x8,1
  63               	.L9:
 276:stk500boot.c  **** 		fastWriteLow(SPI_CLK); // clock auf high, zu fallender flanke werden daten �bernommen
  64               		.loc 1 276 0
  65 002c 4298      		cbi 0x8,2
 277:stk500boot.c  **** 		fastWriteHigh(SPI_CLK); // clock auf high, zu fallender flanke werden daten �bernommen
  66               		.loc 1 277 0
  67 002e 429A      		sbi 0x8,2
 278:stk500boot.c  **** 		b=b>>1;	/* bitmaske einen nach recht schieben => msb first ?! */
  68               		.loc 1 278 0
  69 0030 2695      		lsr r18
  70               	.LVL4:
  71 0032 9150      		subi r25,lo8(-(-1))
 271:stk500boot.c  **** 	for(a=0;a<8;a++){ /* a = 0..7, wegen 8 pixel zeichen breite */
  72               		.loc 1 271 0
  73 0034 01F4      		brne .L10
 279:stk500boot.c  **** 	}
 280:stk500boot.c  **** 	fastWriteHigh(SPI_CS); // cs auf high => deaktivieren
  74               		.loc 1 280 0
  75 0036 439A      		sbi 0x8,3
  76 0038 0895      		ret
  77               	.LFE11:
  80               	send_command:
  81               	.LFB12:
 281:stk500boot.c  **** }
 282:stk500boot.c  **** 
 283:stk500boot.c  **** /////////////////////////////// command funktion ///////////////////////////////
 284:stk500boot.c  **** static void send_command(unsigned char theCommand){
  82               		.loc 1 284 0
  83               	.LVL5:
  84               	/* prologue: function */
  85               	/* frame size = 0 */
  86               	/* stack size = 0 */
  87               	.L__stack_usage = 0
 285:stk500boot.c  **** 	fastWriteLow(SPI_CD); //turn to command mode
  88               		.loc 1 285 0
  89 003a 4798      		cbi 0x8,7
 286:stk500boot.c  **** 	senden_spi(theCommand);
  90               		.loc 1 286 0
  91 003c 0E94 0000 		call senden_spi
  92               	.LVL6:
 287:stk500boot.c  **** 	fastWriteHigh(SPI_CD); //turn to data mode
  93               		.loc 1 287 0
  94 0040 479A      		sbi 0x8,7
  95 0042 0895      		ret
  96               	.LFE12:
  99               	send_char:
 100               	.LFB13:
 288:stk500boot.c  **** }
 289:stk500boot.c  **** 
 290:stk500boot.c  **** /////////////////////////////// data funktion ///////////////////////////////
 291:stk500boot.c  **** static void send_char(unsigned char zeichen){
 101               		.loc 1 291 0
 102               	.LVL7:
 103               	/* prologue: function */
 104               	/* frame size = 0 */
 105               	/* stack size = 0 */
 106               	.L__stack_usage = 0
 292:stk500boot.c  **** 	fastWriteHigh(SPI_CD); //turn to data mode
 107               		.loc 1 292 0
 108 0044 479A      		sbi 0x8,7
 293:stk500boot.c  **** 	senden_spi(zeichen);
 109               		.loc 1 293 0
 110 0046 0C94 0000 		jmp senden_spi
 111               	.LVL8:
 112               	.LFE13:
 114               		.section	.text.unlikely,"ax",@progbits
 116               	draw_line.constprop.0:
 117               	.LFB20:
 294:stk500boot.c  **** }
 295:stk500boot.c  **** //************************************************************************	
 296:stk500boot.c  **** 
 297:stk500boot.c  **** //************************************************************************
 298:stk500boot.c  **** // init display
 299:stk500boot.c  **** static void init_display(void){
 300:stk500boot.c  **** 	DDRC = 0x00 | (1<<PC7) | (1<<PC5) | (1<<PC3) | (1<<PC2) | (1<<PC1);
 301:stk500boot.c  **** 
 302:stk500boot.c  **** 	_delay_ms(1); // TODO: Change to 1 ?
 303:stk500boot.c  **** 
 304:stk500boot.c  **** 	fastWriteHigh(SPI_CS);
 305:stk500boot.c  **** 	fastWriteLow(SPI_CD);
 306:stk500boot.c  **** 	fastWriteLow(SPI_DATA);
 307:stk500boot.c  **** 	fastWriteLow(SPI_CLK);
 308:stk500boot.c  **** 
 309:stk500boot.c  **** 	// reset
 310:stk500boot.c  **** 	fastWriteLow(SPI_RESET);
 311:stk500boot.c  **** 	_delay_ms(1);
 312:stk500boot.c  **** 	fastWriteHigh(SPI_RESET);
 313:stk500boot.c  **** 	//_delay_ms(1);
 314:stk500boot.c  **** 
 315:stk500boot.c  **** 	// init sequenze
 316:stk500boot.c  **** 	/////////////////////////////
 317:stk500boot.c  **** 	// XXXXXX | Normale | 180� //
 318:stk500boot.c  **** 	// ----------------------- //
 319:stk500boot.c  **** 	// Re-Map | 0x41 | 0x52 //
 320:stk500boot.c  **** 	// Offset | 0x44 | 0x4C //
 321:stk500boot.c  **** 	/////////////////////////////
 322:stk500boot.c  **** 
 323:stk500boot.c  **** 	send_command(0x15);	send_command(0x00);	send_command(0x3F);	// Column Address
 324:stk500boot.c  **** 	send_command(0x75);	send_command(0x00);	send_command(0x3F);
 325:stk500boot.c  **** 	send_command(0x81);	send_command(0x66);	// Contrast Control
 326:stk500boot.c  **** 	send_command(0x86);// Current Range
 327:stk500boot.c  **** 	send_command(0xA0);	send_command(0x52);// Re-map
 328:stk500boot.c  **** 	send_command(0xA1);	send_command(0x00);// Display Start Line
 329:stk500boot.c  **** 	send_command(0xA2);	send_command(0x4C);// Display Offset
 330:stk500boot.c  **** 	send_command(0xA4);// Display Mode
 331:stk500boot.c  **** 	send_command(0xA8);	send_command(0x3F);// Multiplex Ratio
 332:stk500boot.c  **** 	send_command(0xB1);	send_command(0xA8);// set prechange // Phase Length
 333:stk500boot.c  **** 	send_command(0xB2);	send_command(0x46);// Row Period
 334:stk500boot.c  **** 	send_command(0xB3);	send_command(0xF1); // war f1 // Display Clock Divide
 335:stk500boot.c  **** 	send_command(0xBF);	send_command(0x0D);// VSL
 336:stk500boot.c  **** 	send_command(0xBE);	send_command(0x02);	send_command(0xBC);	send_command(0x38); // VCOMH
 337:stk500boot.c  **** 	send_command(0xB8);	send_command(0x01);	send_command(0x11);	send_command(0x22);	send_command(0x32)
 338:stk500boot.c  **** 	send_command(0x43);	send_command(0x54);	send_command(0x65);	send_command(0x76);
 339:stk500boot.c  **** 	send_command(0xAD); /* Set DC-DC */
 340:stk500boot.c  **** 	send_command(0x02); /* 03=ON, 02=Off */
 341:stk500boot.c  **** 	send_command(0xAF); // Display ON/OFF
 342:stk500boot.c  **** 	/* AF=ON, AE=Sleep Mode */
 343:stk500boot.c  **** };
 344:stk500boot.c  **** 
 345:stk500boot.c  **** // display filled rect
 346:stk500boot.c  **** static void clear_screen(void){
 347:stk500boot.c  **** 	send_command(0x15);
 348:stk500boot.c  **** 	send_command(0x00);
 349:stk500boot.c  **** 	send_command(0x7F);
 350:stk500boot.c  **** 	send_command(0x75);
 351:stk500boot.c  **** 	send_command(0x00);
 352:stk500boot.c  **** 	send_command(0x3F);
 353:stk500boot.c  **** 	int a;
 354:stk500boot.c  **** 	for (a=0;a<(128*32);a++){
 355:stk500boot.c  **** 		send_char(0x00);
 356:stk500boot.c  **** 	}
 357:stk500boot.c  **** }
 358:stk500boot.c  **** 
 359:stk500boot.c  **** // display horizontal line
 360:stk500boot.c  **** static void draw_line(unsigned char x,unsigned char y,unsigned char width){
 118               		.loc 1 360 0
 119               	.LVL9:
 120 0000 CF93      		push r28
 121               	.LCFI0:
 122 0002 DF93      		push r29
 123               	.LCFI1:
 124               	/* prologue: function */
 125               	/* frame size = 0 */
 126               	/* stack size = 2 */
 127               	.L__stack_usage = 2
 128 0004 C82F      		mov r28,r24
 129               	.LVL10:
 361:stk500boot.c  **** 	send_command(0x15);
 130               		.loc 1 361 0
 131 0006 85E1      		ldi r24,lo8(21)
 132               	.LVL11:
 133 0008 0E94 0000 		call send_command
 134               	.LVL12:
 362:stk500boot.c  **** 	send_command(x/2);
 135               		.loc 1 362 0
 136 000c 80E0      		ldi r24,0
 137 000e 0E94 0000 		call send_command
 138               	.LVL13:
 363:stk500boot.c  **** 	send_command((width-1+x)/2);
 139               		.loc 1 363 0
 140 0012 8FE3      		ldi r24,lo8(63)
 141 0014 0E94 0000 		call send_command
 142               	.LVL14:
 364:stk500boot.c  **** 	send_command(0x75);
 143               		.loc 1 364 0
 144 0018 85E7      		ldi r24,lo8(117)
 145 001a 0E94 0000 		call send_command
 146               	.LVL15:
 365:stk500boot.c  **** 	send_command(y);
 147               		.loc 1 365 0
 148 001e 8C2F      		mov r24,r28
 149 0020 0E94 0000 		call send_command
 150               	.LVL16:
 366:stk500boot.c  **** 	send_command(y);
 151               		.loc 1 366 0
 152 0024 8C2F      		mov r24,r28
 153 0026 0E94 0000 		call send_command
 154               	.LVL17:
 155 002a C0E4      		ldi r28,lo8(64)
 156 002c D0E0      		ldi r29,0
 157               	.LVL18:
 158               	.L15:
 367:stk500boot.c  **** 	int a;
 368:stk500boot.c  **** 	for(a=0;a<(width/2);a++){
 369:stk500boot.c  **** 		send_char(0xff);
 159               		.loc 1 369 0
 160 002e 8FEF      		ldi r24,lo8(-1)
 161 0030 0E94 0000 		call send_char
 162               	.LVL19:
 163 0034 2197      		sbiw r28,1
 368:stk500boot.c  **** 	for(a=0;a<(width/2);a++){
 164               		.loc 1 368 0
 165 0036 01F4      		brne .L15
 166               	/* epilogue start */
 370:stk500boot.c  **** 	};
 371:stk500boot.c  **** }
 167               		.loc 1 371 0
 168 0038 DF91      		pop r29
 169 003a CF91      		pop r28
 170 003c 0895      		ret
 171               	.LFE20:
 173               		.section	.init9,"ax",@progbits
 174               	.global	__jumpMain
 176               	__jumpMain:
 177               	.LFB7:
 220:stk500boot.c  **** {
 178               		.loc 1 220 0
 179               	/* prologue: naked */
 180               	/* frame size = 0 */
 181               	/* stack size = 0 */
 182               	.L__stack_usage = 0
 224:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 183               		.loc 1 224 0
 184               	/* #APP */
 185               	 ;  224 "stk500boot.c" 1
 186               		.set __stack, 8703
 187               	 ;  0 "" 2
 226:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 188               		.loc 1 226 0
 189               	 ;  226 "stk500boot.c" 1
 190 0000 01E2      		ldi	16, 33
 191               	 ;  0 "" 2
 227:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 192               		.loc 1 227 0
 193               	 ;  227 "stk500boot.c" 1
 194 0002 0EBF      		out 62,16
 195               	 ;  0 "" 2
 228:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 196               		.loc 1 228 0
 197               	 ;  228 "stk500boot.c" 1
 198 0004 0FEF      		ldi	16, 255
 199               	 ;  0 "" 2
 229:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 200               		.loc 1 229 0
 201               	 ;  229 "stk500boot.c" 1
 202 0006 0DBF      		out 61,16
 203               	 ;  0 "" 2
 230:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
 204               		.loc 1 230 0
 205               	 ;  230 "stk500boot.c" 1
 206 0008 1124      		clr __zero_reg__
 207               	 ;  0 "" 2
 231:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 208               		.loc 1 231 0
 209               	 ;  231 "stk500boot.c" 1
 210 000a 1FBE      		out 63, __zero_reg__
 211               	 ;  0 "" 2
 232:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 212               		.loc 1 232 0
 213               	 ;  232 "stk500boot.c" 1
 214 000c 0C94 0000 		jmp main
 215               	 ;  0 "" 2
 216               	/* epilogue start */
 233:stk500boot.c  **** }
 217               		.loc 1 233 0
 218               	/* #NOAPP */
 219               	.LFE7:
 221               		.text
 222               	.global	delay_ms
 224               	delay_ms:
 225               	.LFB8:
 238:stk500boot.c  **** {
 226               		.loc 1 238 0
 227               	.LVL20:
 228               	/* prologue: function */
 229               	/* frame size = 0 */
 230               	/* stack size = 0 */
 231               	.L__stack_usage = 0
 240:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 232               		.loc 1 240 0
 233 004a 20E0      		ldi r18,0
 234 004c 30E0      		ldi r19,0
 235 004e 00C0      		rjmp .L19
 236               	.LVL21:
 237               	.L20:
 238               	.LBB27:
 239               	.LBB28:
 240               		.file 2 "/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h"
   1:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** #endif
 103:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
 104:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** /**
 105:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
 109:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
 112:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
 120:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
 129:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
 132:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
 140:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****  */
 141:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** void
 142:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** {
 144:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
 156:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
 159:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 
 164:/usr/lib/gcc/avr/4.7.0/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 241               		.loc 2 164 0
 242 0050 EFEC      		ldi r30,lo8(1999)
 243 0052 F7E0      		ldi r31,hi8(1999)
 244 0054 3197      		1: sbiw r30,1
 245 0056 01F4      		brne 1b
 246 0058 00C0      		rjmp .
 247 005a 0000      		nop
 248               	.LBE28:
 249               	.LBE27:
 240:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 250               		.loc 1 240 0
 251 005c 2F5F      		subi r18,-1
 252 005e 3F4F      		sbci r19,-1
 253               	.LVL22:
 254               	.L19:
 240:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 255               		.loc 1 240 0 is_stmt 0 discriminator 1
 256 0060 2817      		cp r18,r24
 257 0062 3907      		cpc r19,r25
 258 0064 01F4      		brne .L20
 259               	/* epilogue start */
 244:stk500boot.c  **** }
 260               		.loc 1 244 0 is_stmt 1
 261 0066 0895      		ret
 262               	.LFE8:
 264               		.section	.text.startup,"ax",@progbits
 265               	.global	main
 267               	main:
 268               	.LFB19:
 372:stk500boot.c  **** 
 373:stk500boot.c  **** static void show_logo(void){
 374:stk500boot.c  **** 	unsigned char a,zeile,buchstabe;
 375:stk500boot.c  **** 	unsigned char x=15;
 376:stk500boot.c  **** 	unsigned char y=47;
 377:stk500boot.c  **** 
 378:stk500boot.c  **** 	unsigned char data,send_me;
 379:stk500boot.c  **** 	for(a=0;a<9;a++){
 380:stk500boot.c  **** 		if(a==0){ // S
 381:stk500boot.c  **** 			buchstabe=5;
 382:stk500boot.c  **** 		} else if(a==1){ // P
 383:stk500boot.c  **** 			buchstabe=6;
 384:stk500boot.c  **** 		} else if(a==2 || a==3){ // E
 385:stk500boot.c  **** 			buchstabe=0;
 386:stk500boot.c  **** 		} else if(a==4){ // D
 387:stk500boot.c  **** 			buchstabe=1;
 388:stk500boot.c  **** 		} else if(a==5 || a==8){ // O
 389:stk500boot.c  **** 			buchstabe=4;
 390:stk500boot.c  **** 		} else if(a==6){ // I
 391:stk500boot.c  **** 			buchstabe=2;
 392:stk500boot.c  **** 		} else if(a==7){ // N
 393:stk500boot.c  **** 			buchstabe=3;
 394:stk500boot.c  **** 		}
 395:stk500boot.c  **** 		// SPEEDOINO
 396:stk500boot.c  **** 		send_command(0x15);
 397:stk500boot.c  **** 		send_command(x);
 398:stk500boot.c  **** 		send_command(x+2); // buchstaben sind 5px breit + spacer
 399:stk500boot.c  **** 		send_command(0x75);
 400:stk500boot.c  **** 		send_command(y);
 401:stk500boot.c  **** 		send_command(y+5); // und 5 px hoch
 402:stk500boot.c  **** 
 403:stk500boot.c  **** 		buchstabe=buchstabe*6;
 404:stk500boot.c  **** 		for(zeile=0;zeile<6;zeile++){
 405:stk500boot.c  **** 			data=speedoino_data[buchstabe];
 406:stk500boot.c  **** 			buchstabe++;
 407:stk500boot.c  **** 
 408:stk500boot.c  **** 			send_me=0x00;
 409:stk500boot.c  **** 			if(data&0b10000000)	send_me|=0xf0;
 410:stk500boot.c  **** 			if(data&0b01000000)	send_me|=0x0f;
 411:stk500boot.c  **** 			send_char(send_me);
 412:stk500boot.c  **** 
 413:stk500boot.c  **** 			send_me=0x00;
 414:stk500boot.c  **** 			if(data&0b00100000)	send_me|=0xf0;
 415:stk500boot.c  **** 			if(data&0b00010000)	send_me|=0x0f;
 416:stk500boot.c  **** 			send_char(send_me);
 417:stk500boot.c  **** 
 418:stk500boot.c  **** 			send_me=0x00;
 419:stk500boot.c  **** 			if(data&0b00001000)	send_me|=0xf0;
 420:stk500boot.c  **** 			if(data&0b00000100)	send_me|=0x0f;
 421:stk500boot.c  **** 			send_char(send_me);
 422:stk500boot.c  **** 		};
 423:stk500boot.c  **** 
 424:stk500boot.c  **** 		x+=3;
 425:stk500boot.c  **** 	};
 426:stk500boot.c  **** }
 427:stk500boot.c  **** 
 428:stk500boot.c  **** //************************************************************************
 429:stk500boot.c  **** 
 430:stk500boot.c  **** 
 431:stk500boot.c  **** 
 432:stk500boot.c  **** #define	 MAX_TIME_COUNT	(F_CPU >> 1)
 433:stk500boot.c  **** //*****************************************************************************
 434:stk500boot.c  **** static unsigned char recchar_timeout(void)
 435:stk500boot.c  **** {
 436:stk500boot.c  **** 	uint32_t count = 0;
 437:stk500boot.c  **** 
 438:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 439:stk500boot.c  **** 	{
 440:stk500boot.c  **** 		// wait for data
 441:stk500boot.c  **** 		count++;
 442:stk500boot.c  **** 		if (count > MAX_TIME_COUNT)
 443:stk500boot.c  **** 		{
 444:stk500boot.c  **** 			unsigned int	data;
 445:stk500boot.c  **** #if (FLASHEND > 0x0FFFF)
 446:stk500boot.c  **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 447:stk500boot.c  **** #else
 448:stk500boot.c  **** 			data	=	pgm_read_word_near(0);	//*	get the first word of the user program
 449:stk500boot.c  **** #endif
 450:stk500boot.c  **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 451:stk500boot.c  **** 			{
 452:stk500boot.c  **** 				asm volatile(
 453:stk500boot.c  **** 						"clr	r30		\n\t"
 454:stk500boot.c  **** 						"clr	r31		\n\t"
 455:stk500boot.c  **** 						"ijmp	\n\t"
 456:stk500boot.c  **** 				);
 457:stk500boot.c  **** 			}
 458:stk500boot.c  **** 			count	=	0;
 459:stk500boot.c  **** 		}
 460:stk500boot.c  **** 	}
 461:stk500boot.c  **** 	return UART_DATA_REG;
 462:stk500boot.c  **** }
 463:stk500boot.c  **** 
 464:stk500boot.c  **** 
 465:stk500boot.c  **** 
 466:stk500boot.c  **** //*****************************************************************************
 467:stk500boot.c  **** int main(void)
 468:stk500boot.c  **** {
 269               		.loc 1 468 0
 270 0000 CF93      		push r28
 271               	.LCFI2:
 272 0002 DF93      		push r29
 273               	.LCFI3:
 274 0004 CDB7      		in r28,__SP_L__
 275 0006 DEB7      		in r29,__SP_H__
 276               	.LCFI4:
 277 0008 CB52      		subi r28,43
 278 000a D140      		sbci r29,1
 279               	.LCFI5:
 280 000c 0FB6      		in __tmp_reg__,__SREG__
 281 000e F894      		cli
 282 0010 DEBF      		out __SP_H__,r29
 283 0012 0FBE      		out __SREG__,__tmp_reg__
 284 0014 CDBF      		out __SP_L__,r28
 285               	/* prologue: function */
 286               	/* frame size = 299 */
 287               	/* stack size = 301 */
 288               	.L__stack_usage = 301
 289               	.LVL23:
 469:stk500boot.c  **** 	address_t		address			=	0;
 470:stk500boot.c  **** 	address_t		eraseAddress	=	0;
 471:stk500boot.c  **** 	unsigned char	msgParseState;
 472:stk500boot.c  **** 	unsigned int	ii				=	0;
 473:stk500boot.c  **** 	unsigned char	checksum		=	0;
 474:stk500boot.c  **** 	unsigned char	seqNum			=	1;
 475:stk500boot.c  **** 	unsigned int	msgLength		=	0;
 476:stk500boot.c  **** 	unsigned char	msgBuffer[285];
 477:stk500boot.c  **** 	unsigned char	c, *p;
 478:stk500boot.c  **** 	unsigned char   isLeave = 0;
 479:stk500boot.c  **** 
 480:stk500boot.c  **** 	unsigned long	boot_timeout;
 481:stk500boot.c  **** 	unsigned long	boot_timer;
 482:stk500boot.c  **** 	unsigned int	boot_state;
 483:stk500boot.c  **** 
 484:stk500boot.c  **** 	/////////Kolja von hier/////////
 485:stk500boot.c  **** 	/* enabled in ph3 to read if its a bluetooth reset*/
 486:stk500boot.c  **** 	DDRH  &= ~(1<<PH3); // one input
 290               		.loc 1 486 0
 291 0016 8091 0101 		lds r24,257
 292 001a 877F      		andi r24,lo8(-9)
 293 001c 8093 0101 		sts 257,r24
 487:stk500boot.c  **** 	PORTH =  0x00 | (1<<PH3); // with pullup
 294               		.loc 1 487 0
 295 0020 88E0      		ldi r24,lo8(8)
 296 0022 8093 0201 		sts 258,r24
 297               	.LVL24:
 488:stk500boot.c  **** 
 489:stk500boot.c  **** 	/////////Kolja bis hier/////////
 490:stk500boot.c  **** 
 491:stk500boot.c  **** 
 492:stk500boot.c  **** 	boot_timer	=	0;
 493:stk500boot.c  **** 	boot_state	=	0;
 494:stk500boot.c  **** 	boot_timeout	=	250000; // 7 seconds , approx 2us per step when optimize "s"
 495:stk500boot.c  **** 
 496:stk500boot.c  **** 	/*
 497:stk500boot.c  **** 	 * Branch to bootloader or application code ?
 498:stk500boot.c  **** 	 */
 499:stk500boot.c  **** 
 500:stk500boot.c  **** 	/*
 501:stk500boot.c  **** 	 * Init UART
 502:stk500boot.c  **** 	 * set baudrate and enable USART receiver and transmiter without interrupts
 503:stk500boot.c  **** 	 */
 504:stk500boot.c  **** #if UART_BAUDRATE_DOUBLE_SPEED
 505:stk500boot.c  **** 	UART_STATUS_REG		|=	(1 <<UART_DOUBLE_SPEED);
 298               		.loc 1 505 0
 299 0026 8091 C000 		lds r24,192
 300 002a 8260      		ori r24,lo8(2)
 301 002c 8093 C000 		sts 192,r24
 506:stk500boot.c  **** #endif
 507:stk500boot.c  **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 302               		.loc 1 507 0
 303 0030 80E1      		ldi r24,lo8(16)
 304 0032 8093 C400 		sts 196,r24
 508:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 305               		.loc 1 508 0
 306 0036 88E1      		ldi r24,lo8(24)
 307 0038 8093 C100 		sts 193,r24
 509:stk500boot.c  **** 
 510:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 308               		.loc 1 510 0
 309               	/* #APP */
 310               	 ;  510 "stk500boot.c" 1
 311 003c 0000      		nop
 312               	 ;  0 "" 2
 313               	/* #NOAPP */
 314               	.LBB62:
 315               	.LBB63:
 300:stk500boot.c  **** 	DDRC = 0x00 | (1<<PC7) | (1<<PC5) | (1<<PC3) | (1<<PC2) | (1<<PC1);
 316               		.loc 1 300 0
 317 003e 8EEA      		ldi r24,lo8(-82)
 318 0040 87B9      		out 0x7,r24
 319               	.LVL25:
 320               	.LBB64:
 321               	.LBB65:
 322               		.loc 2 164 0
 323 0042 8FE9      		ldi r24,lo8(3999)
 324 0044 9FE0      		ldi r25,hi8(3999)
 325 0046 0197      		1: sbiw r24,1
 326 0048 01F4      		brne 1b
 327 004a 00C0      		rjmp .
 328 004c 0000      		nop
 329               	.LBE65:
 330               	.LBE64:
 304:stk500boot.c  **** 	fastWriteHigh(SPI_CS);
 331               		.loc 1 304 0
 332 004e 439A      		sbi 0x8,3
 305:stk500boot.c  **** 	fastWriteLow(SPI_CD);
 333               		.loc 1 305 0
 334 0050 4798      		cbi 0x8,7
 306:stk500boot.c  **** 	fastWriteLow(SPI_DATA);
 335               		.loc 1 306 0
 336 0052 4198      		cbi 0x8,1
 307:stk500boot.c  **** 	fastWriteLow(SPI_CLK);
 337               		.loc 1 307 0
 338 0054 4298      		cbi 0x8,2
 310:stk500boot.c  **** 	fastWriteLow(SPI_RESET);
 339               		.loc 1 310 0
 340 0056 4598      		cbi 0x8,5
 341               	.LVL26:
 342               	.LBB66:
 343               	.LBB67:
 344               		.loc 2 164 0
 345 0058 EFE9      		ldi r30,lo8(3999)
 346 005a FFE0      		ldi r31,hi8(3999)
 347 005c 3197      		1: sbiw r30,1
 348 005e 01F4      		brne 1b
 349 0060 00C0      		rjmp .
 350 0062 0000      		nop
 351               	.LBE67:
 352               	.LBE66:
 312:stk500boot.c  **** 	fastWriteHigh(SPI_RESET);
 353               		.loc 1 312 0
 354 0064 459A      		sbi 0x8,5
 323:stk500boot.c  **** 	send_command(0x15);	send_command(0x00);	send_command(0x3F);	// Column Address
 355               		.loc 1 323 0
 356 0066 85E1      		ldi r24,lo8(21)
 357 0068 0E94 0000 		call send_command
 358               	.LVL27:
 359 006c 80E0      		ldi r24,0
 360 006e 0E94 0000 		call send_command
 361               	.LVL28:
 362 0072 8FE3      		ldi r24,lo8(63)
 363 0074 0E94 0000 		call send_command
 364               	.LVL29:
 324:stk500boot.c  **** 	send_command(0x75);	send_command(0x00);	send_command(0x3F);
 365               		.loc 1 324 0
 366 0078 85E7      		ldi r24,lo8(117)
 367 007a 0E94 0000 		call send_command
 368               	.LVL30:
 369 007e 80E0      		ldi r24,0
 370 0080 0E94 0000 		call send_command
 371               	.LVL31:
 372 0084 8FE3      		ldi r24,lo8(63)
 373 0086 0E94 0000 		call send_command
 374               	.LVL32:
 325:stk500boot.c  **** 	send_command(0x81);	send_command(0x66);	// Contrast Control
 375               		.loc 1 325 0
 376 008a 81E8      		ldi r24,lo8(-127)
 377 008c 0E94 0000 		call send_command
 378               	.LVL33:
 379 0090 86E6      		ldi r24,lo8(102)
 380 0092 0E94 0000 		call send_command
 381               	.LVL34:
 326:stk500boot.c  **** 	send_command(0x86);// Current Range
 382               		.loc 1 326 0
 383 0096 86E8      		ldi r24,lo8(-122)
 384 0098 0E94 0000 		call send_command
 385               	.LVL35:
 327:stk500boot.c  **** 	send_command(0xA0);	send_command(0x52);// Re-map
 386               		.loc 1 327 0
 387 009c 80EA      		ldi r24,lo8(-96)
 388 009e 0E94 0000 		call send_command
 389               	.LVL36:
 390 00a2 82E5      		ldi r24,lo8(82)
 391 00a4 0E94 0000 		call send_command
 392               	.LVL37:
 328:stk500boot.c  **** 	send_command(0xA1);	send_command(0x00);// Display Start Line
 393               		.loc 1 328 0
 394 00a8 81EA      		ldi r24,lo8(-95)
 395 00aa 0E94 0000 		call send_command
 396               	.LVL38:
 397 00ae 80E0      		ldi r24,0
 398 00b0 0E94 0000 		call send_command
 399               	.LVL39:
 329:stk500boot.c  **** 	send_command(0xA2);	send_command(0x4C);// Display Offset
 400               		.loc 1 329 0
 401 00b4 82EA      		ldi r24,lo8(-94)
 402 00b6 0E94 0000 		call send_command
 403               	.LVL40:
 404 00ba 8CE4      		ldi r24,lo8(76)
 405 00bc 0E94 0000 		call send_command
 406               	.LVL41:
 330:stk500boot.c  **** 	send_command(0xA4);// Display Mode
 407               		.loc 1 330 0
 408 00c0 84EA      		ldi r24,lo8(-92)
 409 00c2 0E94 0000 		call send_command
 410               	.LVL42:
 331:stk500boot.c  **** 	send_command(0xA8);	send_command(0x3F);// Multiplex Ratio
 411               		.loc 1 331 0
 412 00c6 88EA      		ldi r24,lo8(-88)
 413 00c8 0E94 0000 		call send_command
 414               	.LVL43:
 415 00cc 8FE3      		ldi r24,lo8(63)
 416 00ce 0E94 0000 		call send_command
 417               	.LVL44:
 332:stk500boot.c  **** 	send_command(0xB1);	send_command(0xA8);// set prechange // Phase Length
 418               		.loc 1 332 0
 419 00d2 81EB      		ldi r24,lo8(-79)
 420 00d4 0E94 0000 		call send_command
 421               	.LVL45:
 422 00d8 88EA      		ldi r24,lo8(-88)
 423 00da 0E94 0000 		call send_command
 424               	.LVL46:
 333:stk500boot.c  **** 	send_command(0xB2);	send_command(0x46);// Row Period
 425               		.loc 1 333 0
 426 00de 82EB      		ldi r24,lo8(-78)
 427 00e0 0E94 0000 		call send_command
 428               	.LVL47:
 429 00e4 86E4      		ldi r24,lo8(70)
 430 00e6 0E94 0000 		call send_command
 431               	.LVL48:
 334:stk500boot.c  **** 	send_command(0xB3);	send_command(0xF1); // war f1 // Display Clock Divide
 432               		.loc 1 334 0
 433 00ea 83EB      		ldi r24,lo8(-77)
 434 00ec 0E94 0000 		call send_command
 435               	.LVL49:
 436 00f0 81EF      		ldi r24,lo8(-15)
 437 00f2 0E94 0000 		call send_command
 438               	.LVL50:
 335:stk500boot.c  **** 	send_command(0xBF);	send_command(0x0D);// VSL
 439               		.loc 1 335 0
 440 00f6 8FEB      		ldi r24,lo8(-65)
 441 00f8 0E94 0000 		call send_command
 442               	.LVL51:
 443 00fc 8DE0      		ldi r24,lo8(13)
 444 00fe 0E94 0000 		call send_command
 445               	.LVL52:
 336:stk500boot.c  **** 	send_command(0xBE);	send_command(0x02);	send_command(0xBC);	send_command(0x38); // VCOMH
 446               		.loc 1 336 0
 447 0102 8EEB      		ldi r24,lo8(-66)
 448 0104 0E94 0000 		call send_command
 449               	.LVL53:
 450 0108 82E0      		ldi r24,lo8(2)
 451 010a 0E94 0000 		call send_command
 452               	.LVL54:
 453 010e 8CEB      		ldi r24,lo8(-68)
 454 0110 0E94 0000 		call send_command
 455               	.LVL55:
 456 0114 88E3      		ldi r24,lo8(56)
 457 0116 0E94 0000 		call send_command
 458               	.LVL56:
 337:stk500boot.c  **** 	send_command(0xB8);	send_command(0x01);	send_command(0x11);	send_command(0x22);	send_command(0x32)
 459               		.loc 1 337 0
 460 011a 88EB      		ldi r24,lo8(-72)
 461 011c 0E94 0000 		call send_command
 462               	.LVL57:
 463 0120 81E0      		ldi r24,lo8(1)
 464 0122 0E94 0000 		call send_command
 465               	.LVL58:
 466 0126 81E1      		ldi r24,lo8(17)
 467 0128 0E94 0000 		call send_command
 468               	.LVL59:
 469 012c 82E2      		ldi r24,lo8(34)
 470 012e 0E94 0000 		call send_command
 471               	.LVL60:
 472 0132 82E3      		ldi r24,lo8(50)
 473 0134 0E94 0000 		call send_command
 474               	.LVL61:
 338:stk500boot.c  **** 	send_command(0x43);	send_command(0x54);	send_command(0x65);	send_command(0x76);
 475               		.loc 1 338 0
 476 0138 83E4      		ldi r24,lo8(67)
 477 013a 0E94 0000 		call send_command
 478               	.LVL62:
 479 013e 84E5      		ldi r24,lo8(84)
 480 0140 0E94 0000 		call send_command
 481               	.LVL63:
 482 0144 85E6      		ldi r24,lo8(101)
 483 0146 0E94 0000 		call send_command
 484               	.LVL64:
 485 014a 86E7      		ldi r24,lo8(118)
 486 014c 0E94 0000 		call send_command
 487               	.LVL65:
 339:stk500boot.c  **** 	send_command(0xAD); /* Set DC-DC */
 488               		.loc 1 339 0
 489 0150 8DEA      		ldi r24,lo8(-83)
 490 0152 0E94 0000 		call send_command
 491               	.LVL66:
 340:stk500boot.c  **** 	send_command(0x02); /* 03=ON, 02=Off */
 492               		.loc 1 340 0
 493 0156 82E0      		ldi r24,lo8(2)
 494 0158 0E94 0000 		call send_command
 495               	.LVL67:
 341:stk500boot.c  **** 	send_command(0xAF); // Display ON/OFF
 496               		.loc 1 341 0
 497 015c 8FEA      		ldi r24,lo8(-81)
 498 015e 0E94 0000 		call send_command
 499               	.LVL68:
 500               	.LBE63:
 501               	.LBE62:
 502               	.LBB68:
 503               	.LBB69:
 347:stk500boot.c  **** 	send_command(0x15);
 504               		.loc 1 347 0
 505 0162 85E1      		ldi r24,lo8(21)
 506 0164 0E94 0000 		call send_command
 507               	.LVL69:
 348:stk500boot.c  **** 	send_command(0x00);
 508               		.loc 1 348 0
 509 0168 80E0      		ldi r24,0
 510 016a 0E94 0000 		call send_command
 511               	.LVL70:
 349:stk500boot.c  **** 	send_command(0x7F);
 512               		.loc 1 349 0
 513 016e 8FE7      		ldi r24,lo8(127)
 514 0170 0E94 0000 		call send_command
 515               	.LVL71:
 350:stk500boot.c  **** 	send_command(0x75);
 516               		.loc 1 350 0
 517 0174 85E7      		ldi r24,lo8(117)
 518 0176 0E94 0000 		call send_command
 519               	.LVL72:
 351:stk500boot.c  **** 	send_command(0x00);
 520               		.loc 1 351 0
 521 017a 80E0      		ldi r24,0
 522 017c 0E94 0000 		call send_command
 523               	.LVL73:
 352:stk500boot.c  **** 	send_command(0x3F);
 524               		.loc 1 352 0
 525 0180 8FE3      		ldi r24,lo8(63)
 526 0182 0E94 0000 		call send_command
 527               	.LVL74:
 528 0186 00E0      		ldi r16,0
 529 0188 10E1      		ldi r17,lo8(16)
 530               	.LVL75:
 531               	.L22:
 355:stk500boot.c  **** 		send_char(0x00);
 532               		.loc 1 355 0
 533 018a 80E0      		ldi r24,0
 534 018c 0E94 0000 		call send_char
 535               	.LVL76:
 536 0190 0150      		subi r16,1
 537 0192 1109      		sbc r17,__zero_reg__
 354:stk500boot.c  **** 	for (a=0;a<(128*32);a++){
 538               		.loc 1 354 0
 539 0194 01F4      		brne .L22
 540               	.LVL77:
 541               	.LBE69:
 542               	.LBE68:
 511:stk500boot.c  **** 
 512:stk500boot.c  **** 	/////////Kolja von hier/////////
 513:stk500boot.c  **** 	init_display(); // this is the moment when we can init the display
 514:stk500boot.c  **** 	clear_screen();
 515:stk500boot.c  **** 	//_delay_ms(2);
 516:stk500boot.c  **** 	msgLength		=	11;
 517:stk500boot.c  **** 	msgBuffer[0] 	=	CMD_SIGN_ON;
 543               		.loc 1 517 0
 544 0196 81E0      		ldi r24,lo8(1)
 545 0198 8983      		std Y+1,r24
 518:stk500boot.c  **** 	msgBuffer[1] 	=	STATUS_CMD_OK;
 546               		.loc 1 518 0
 547 019a 1A82      		std Y+2,__zero_reg__
 519:stk500boot.c  **** 	msgBuffer[2] 	=	8;
 548               		.loc 1 519 0
 549 019c 88E0      		ldi r24,lo8(8)
 550 019e 8B83      		std Y+3,r24
 520:stk500boot.c  **** 	msgBuffer[3] 	=	'A';
 551               		.loc 1 520 0
 552 01a0 81E4      		ldi r24,lo8(65)
 553 01a2 8C83      		std Y+4,r24
 521:stk500boot.c  **** 	msgBuffer[4] 	=	'V';
 554               		.loc 1 521 0
 555 01a4 86E5      		ldi r24,lo8(86)
 556 01a6 8D83      		std Y+5,r24
 522:stk500boot.c  **** 	msgBuffer[5] 	=	'R';
 557               		.loc 1 522 0
 558 01a8 82E5      		ldi r24,lo8(82)
 559 01aa 8E83      		std Y+6,r24
 523:stk500boot.c  **** 	msgBuffer[6] 	=	'I';
 560               		.loc 1 523 0
 561 01ac 89E4      		ldi r24,lo8(73)
 562 01ae 8F83      		std Y+7,r24
 524:stk500boot.c  **** 	msgBuffer[7] 	=	'S';
 563               		.loc 1 524 0
 564 01b0 83E5      		ldi r24,lo8(83)
 565 01b2 8887      		std Y+8,r24
 525:stk500boot.c  **** 	msgBuffer[8] 	=	'P';
 566               		.loc 1 525 0
 567 01b4 80E5      		ldi r24,lo8(80)
 568 01b6 8987      		std Y+9,r24
 526:stk500boot.c  **** 	msgBuffer[9] 	=	'_';
 569               		.loc 1 526 0
 570 01b8 8FE5      		ldi r24,lo8(95)
 571 01ba 8A87      		std Y+10,r24
 527:stk500boot.c  **** 	msgBuffer[10]	=	'2';
 572               		.loc 1 527 0
 573 01bc 82E3      		ldi r24,lo8(50)
 574 01be 8B87      		std Y+11,r24
 528:stk500boot.c  **** 	sendchar(MESSAGE_START);
 575               		.loc 1 528 0
 576 01c0 8BE1      		ldi r24,lo8(27)
 577 01c2 0E94 0000 		call sendchar
 578               	.LVL78:
 529:stk500boot.c  **** 	checksum	=	MESSAGE_START^0;
 530:stk500boot.c  **** 
 531:stk500boot.c  **** 	sendchar(seqNum);
 579               		.loc 1 531 0
 580 01c6 81E0      		ldi r24,lo8(1)
 581 01c8 0E94 0000 		call sendchar
 582               	.LVL79:
 532:stk500boot.c  **** 	checksum	^=	seqNum;
 533:stk500boot.c  **** 
 534:stk500boot.c  **** 	c			=	((msgLength>>8)&0xFF);
 535:stk500boot.c  **** 	sendchar(c);
 583               		.loc 1 535 0
 584 01cc 80E0      		ldi r24,0
 585 01ce 0E94 0000 		call sendchar
 586               	.LVL80:
 536:stk500boot.c  **** 	checksum	^=	c;
 537:stk500boot.c  **** 
 538:stk500boot.c  **** 	c			=	msgLength&0x00FF;
 539:stk500boot.c  **** 	sendchar(c);
 587               		.loc 1 539 0
 588 01d2 8BE0      		ldi r24,lo8(11)
 589 01d4 0E94 0000 		call sendchar
 590               	.LVL81:
 540:stk500boot.c  **** 	checksum ^= c;
 541:stk500boot.c  **** 
 542:stk500boot.c  **** 	sendchar(TOKEN);
 591               		.loc 1 542 0
 592 01d8 8EE0      		ldi r24,lo8(14)
 593 01da 0E94 0000 		call sendchar
 594               	.LVL82:
 543:stk500boot.c  **** 	checksum ^= TOKEN;
 544:stk500boot.c  **** 
 545:stk500boot.c  **** 	p	=	msgBuffer;
 595               		.loc 1 545 0
 596 01de 8E01      		movw r16,r28
 597 01e0 0F5F      		subi r16,-1
 598 01e2 1F4F      		sbci r17,-1
 543:stk500boot.c  **** 	checksum ^= TOKEN;
 599               		.loc 1 543 0
 600 01e4 9FE1      		ldi r25,lo8(31)
 601 01e6 792E      		mov r7,r25
 467:stk500boot.c  **** int main(void)
 602               		.loc 1 467 0
 603 01e8 7E01      		movw r14,r28
 604 01ea FCE0      		ldi r31,12
 605 01ec EF0E      		add r14,r31
 606 01ee F11C      		adc r15,__zero_reg__
 607               	.LVL83:
 608               	.L23:
 546:stk500boot.c  **** 	while ( msgLength )
 547:stk500boot.c  **** 	{
 548:stk500boot.c  **** 		c	=	*p++;
 609               		.loc 1 548 0
 610 01f0 F801      		movw r30,r16
 611 01f2 D190      		ld r13,Z+
 612 01f4 8F01      		movw r16,r30
 613               	.LVL84:
 549:stk500boot.c  **** 		sendchar(c);
 614               		.loc 1 549 0
 615 01f6 8D2D      		mov r24,r13
 616 01f8 0E94 0000 		call sendchar
 617               	.LVL85:
 550:stk500boot.c  **** 		checksum ^=c;
 618               		.loc 1 550 0
 619 01fc 7D24      		eor r7,r13
 620               	.LVL86:
 546:stk500boot.c  **** 	while ( msgLength )
 621               		.loc 1 546 0
 622 01fe 0E15      		cp r16,r14
 623 0200 1F05      		cpc r17,r15
 624 0202 01F4      		brne .L23
 551:stk500boot.c  **** 		msgLength--;
 552:stk500boot.c  **** 	}
 553:stk500boot.c  **** 	sendchar(checksum);
 625               		.loc 1 553 0
 626 0204 872D      		mov r24,r7
 627 0206 0E94 0000 		call sendchar
 628               	.LVL87:
 492:stk500boot.c  **** 	boot_timer	=	0;
 629               		.loc 1 492 0
 630 020a 40E0      		ldi r20,0
 631 020c 50E0      		ldi r21,0
 632 020e BA01      		movw r22,r20
 633 0210 00C0      		rjmp .L176
 634               	.LVL88:
 635               	.L29:
 636               	.LBB70:
 637               	.LBB71:
 638               		.loc 2 164 0
 639 0212 F5E0      		ldi r31,lo8(5)
 640 0214 FA95      		1: dec r31
 641 0216 01F4      		brne 1b
 642 0218 0000      		nop
 643               	.LBE71:
 644               	.LBE70:
 554:stk500boot.c  **** 	seqNum++;
 555:stk500boot.c  **** 
 556:stk500boot.c  **** 
 557:stk500boot.c  **** 	//filled_rect(0,0,128,20,0xff);
 558:stk500boot.c  **** 	/////////Kolja bis hier /////////
 559:stk500boot.c  **** 
 560:stk500boot.c  **** 	while (boot_state==0)
 561:stk500boot.c  **** 	{
 562:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 563:stk500boot.c  **** 		{
 564:stk500boot.c  **** 			_delay_ms(0.001);
 565:stk500boot.c  **** 			/////////Kolja von hier /////////
 566:stk500boot.c  **** 			// nur wenn das bit gesetzt ist
 567:stk500boot.c  **** 			if(bit_is_set(PINH,3)){
 645               		.loc 1 567 0
 646 021a 8091 0001 		lds r24,256
 647 021e 83FF      		sbrs r24,3
 648 0220 00C0      		rjmp .L25
 568:stk500boot.c  **** 				/////////Kolja bis hier/////////
 569:stk500boot.c  **** 				boot_timer++;
 649               		.loc 1 569 0
 650 0222 4F5F      		subi r20,-1
 651 0224 5F4F      		sbci r21,-1
 652 0226 6F4F      		sbci r22,-1
 653 0228 7F4F      		sbci r23,-1
 654               	.LVL89:
 655               	.L25:
 570:stk500boot.c  **** 				/////////Kolja von hier /////////
 571:stk500boot.c  **** 			}
 572:stk500boot.c  **** 			/////////Kolja bis hier /////////
 573:stk500boot.c  **** 
 574:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 656               		.loc 1 574 0
 657 022a A1E0      		ldi r26,lo8(1)
 658 022c B0E0      		ldi r27,0
 659               	.LVL90:
 660 022e 4139      		cpi r20,-111
 661 0230 00ED      		ldi r16,-48
 662 0232 5007      		cpc r21,r16
 663 0234 03E0      		ldi r16,3
 664 0236 6007      		cpc r22,r16
 665 0238 7105      		cpc r23,__zero_reg__
 666 023a 00F4      		brsh .L31
 667               	.LVL91:
 668               	.L176:
 669 023c A0E0      		ldi r26,0
 670 023e B0E0      		ldi r27,0
 671               	.L31:
 672               	.LVL92:
 673               	.LBB72:
 674               	.LBB73:
 261:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 675               		.loc 1 261 0 discriminator 1
 676 0240 8091 C000 		lds r24,192
 677               	.LBE73:
 678               	.LBE72:
 562:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 679               		.loc 1 562 0 discriminator 1
 680 0244 87FF      		sbrs r24,7
 681 0246 00C0      		rjmp .L27
 682               	.L30:
 575:stk500boot.c  **** 			{
 576:stk500boot.c  **** 				boot_state	=	1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 577:stk500boot.c  **** 			}
 578:stk500boot.c  **** 		}
 579:stk500boot.c  **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 683               		.loc 1 579 0
 684 0248 1196      		adiw r26,1
 685               	.LVL93:
 560:stk500boot.c  **** 	while (boot_state==0)
 686               		.loc 1 560 0
 687 024a 01F0      		breq .L176
 688 024c 00C0      		rjmp .L173
 689               	.L27:
 562:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 690               		.loc 1 562 0 discriminator 2
 691 024e 1097      		sbiw r26,0
 692 0250 01F0      		breq .L29
 693 0252 00C0      		rjmp .L30
 694               	.L173:
 580:stk500boot.c  **** 	}
 581:stk500boot.c  **** 
 582:stk500boot.c  **** 
 583:stk500boot.c  **** 	if (boot_state==1)
 695               		.loc 1 583 0
 696 0254 A130      		cpi r26,1
 697 0256 B105      		cpc r27,__zero_reg__
 698 0258 01F0      		breq .+2
 699 025a 00C0      		rjmp .L33
 700 025c 00C0      		rjmp .L102
 701               	.LVL94:
 702               	.L66:
 703 025e A0E0      		ldi r26,0
 704 0260 B0E0      		ldi r27,0
 705               	.LVL95:
 706               	.L100:
 584:stk500boot.c  **** 	{
 585:stk500boot.c  **** 		//*	main loop
 586:stk500boot.c  **** 		while (!isLeave)
 587:stk500boot.c  **** 		{
 588:stk500boot.c  **** 			/*
 589:stk500boot.c  **** 			 * Collect received bytes to a complete message
 590:stk500boot.c  **** 			 */
 591:stk500boot.c  **** 			msgParseState	=	ST_START;
 592:stk500boot.c  **** 			while ( msgParseState != ST_PROCESS )
 593:stk500boot.c  **** 			{
 594:stk500boot.c  **** 				if (boot_state==1)
 707               		.loc 1 594 0
 708 0262 1197      		sbiw r26,1
 709 0264 01F4      		brne .L103
 710               	.LVL96:
 711 0266 00C0      		rjmp .L177
 712               	.LVL97:
 713               	.L37:
 714               	.LBB74:
 715               	.LBB75:
 441:stk500boot.c  **** 		count++;
 716               		.loc 1 441 0
 717 0268 9FEF      		ldi r25,-1
 718 026a C91A      		sub r12,r25
 719 026c D90A      		sbc r13,r25
 720 026e E90A      		sbc r14,r25
 721 0270 F90A      		sbc r15,r25
 722               	.LVL98:
 442:stk500boot.c  **** 		if (count > MAX_TIME_COUNT)
 723               		.loc 1 442 0
 724 0272 A1E0      		ldi r26,1
 725 0274 CA16      		cp r12,r26
 726 0276 A2E1      		ldi r26,18
 727 0278 DA06      		cpc r13,r26
 728 027a AAE7      		ldi r26,122
 729 027c EA06      		cpc r14,r26
 730 027e F104      		cpc r15,__zero_reg__
 731 0280 00F0      		brlo .L172
 732               	.LVL99:
 733               	.LBB76:
 450:stk500boot.c  **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 734               		.loc 1 450 0
 735 0282 CC5D      		subi r28,lo8(-292)
 736 0284 DE4F      		sbci r29,hi8(-292)
 737 0286 E881      		ld r30,Y
 738 0288 F981      		ldd r31,Y+1
 739 028a C452      		subi r28,lo8(292)
 740 028c D140      		sbci r29,hi8(292)
 741 028e 3196      		adiw r30,1
 742 0290 01F0      		breq .L103
 452:stk500boot.c  **** 				asm volatile(
 743               		.loc 1 452 0
 744               	/* #APP */
 745               	 ;  452 "stk500boot.c" 1
 746 0292 EE27      		clr	r30		
 747 0294 FF27      		clr	r31		
 748 0296 0994      		ijmp	
 749               		
 750               	 ;  0 "" 2
 751               	.LVL100:
 752               	/* #NOAPP */
 753               	.L103:
 754               	.LBE76:
 755               	.LBE75:
 756               	.LBE74:
 757               		.loc 1 594 0
 758 0298 C12C      		mov r12,__zero_reg__
 759 029a D12C      		mov r13,__zero_reg__
 760 029c 7601      		movw r14,r12
 761               	.L172:
 762               	.LVL101:
 763               	.LBB81:
 764               	.LBB79:
 438:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 765               		.loc 1 438 0
 766 029e 9091 C000 		lds r25,192
 767 02a2 97FF      		sbrs r25,7
 768 02a4 00C0      		rjmp .L37
 769               	.LVL102:
 770               	.L177:
 461:stk500boot.c  **** 	return UART_DATA_REG;
 771               		.loc 1 461 0
 772 02a6 9091 C600 		lds r25,198
 773               	.LVL103:
 774               	.LBE79:
 775               	.LBE81:
 595:stk500boot.c  **** 				{
 596:stk500boot.c  **** 					boot_state	=	0;
 597:stk500boot.c  **** 					c			=	UART_DATA_REG;
 598:stk500boot.c  **** 				}
 599:stk500boot.c  **** 				else
 600:stk500boot.c  **** 				{
 601:stk500boot.c  **** 					c	=	recchar_timeout();
 602:stk500boot.c  **** 				}
 603:stk500boot.c  **** 
 604:stk500boot.c  **** 
 605:stk500boot.c  **** 
 606:stk500boot.c  **** 				switch (msgParseState){
 776               		.loc 1 606 0
 777 02aa 8330      		cpi r24,lo8(3)
 778 02ac 01F0      		breq .L42
 779 02ae 00F4      		brsh .L46
 780 02b0 8130      		cpi r24,lo8(1)
 781 02b2 01F0      		breq .L40
 782 02b4 00F4      		brsh .L41
 783 02b6 00C0      		rjmp .L174
 784               	.L46:
 785 02b8 8530      		cpi r24,lo8(5)
 786 02ba 01F0      		breq .L44
 787 02bc 00F0      		brlo .L43
 788 02be 8630      		cpi r24,lo8(6)
 789 02c0 01F0      		breq .+2
 790 02c2 00C0      		rjmp .L175
 791 02c4 00C0      		rjmp .L45
 792               	.L174:
 607:stk500boot.c  **** 				case ST_START:
 608:stk500boot.c  **** 					if ( c == MESSAGE_START )
 793               		.loc 1 608 0
 794 02c6 9B31      		cpi r25,lo8(27)
 795 02c8 01F4      		brne .L66
 796 02ca 00C0      		rjmp .L105
 797               	.L40:
 609:stk500boot.c  **** 					{
 610:stk500boot.c  **** 						msgParseState	=	ST_GET_SEQ_NUM;
 611:stk500boot.c  **** 						checksum		=	MESSAGE_START^0;
 612:stk500boot.c  **** 					}
 613:stk500boot.c  **** 					break;
 614:stk500boot.c  **** 
 615:stk500boot.c  **** 				case ST_GET_SEQ_NUM:
 616:stk500boot.c  **** 					if ( (c == 1) || (c == seqNum) )
 798               		.loc 1 616 0
 799 02cc 9130      		cpi r25,lo8(1)
 800 02ce 01F0      		breq .L48
 801               		.loc 1 616 0 is_stmt 0 discriminator 1
 802 02d0 9113      		cpse r25,r17
 803 02d2 00C0      		rjmp .L109
 804               	.L48:
 805               	.LVL104:
 617:stk500boot.c  **** 					{
 618:stk500boot.c  **** 						seqNum			=	c;
 619:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_1;
 620:stk500boot.c  **** 						checksum		^=	c;
 806               		.loc 1 620 0 is_stmt 1
 807 02d4 7926      		eor r7,r25
 808               	.LVL105:
 809 02d6 192F      		mov r17,r25
 619:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_1;
 810               		.loc 1 619 0
 811 02d8 82E0      		ldi r24,lo8(2)
 812               		.loc 1 620 0
 813 02da 00C0      		rjmp .L66
 814               	.LVL106:
 815               	.L41:
 621:stk500boot.c  **** 					}
 622:stk500boot.c  **** 					else
 623:stk500boot.c  **** 					{
 624:stk500boot.c  **** 						msgParseState	=	ST_START;
 625:stk500boot.c  **** 					}
 626:stk500boot.c  **** 					break;
 627:stk500boot.c  **** 
 628:stk500boot.c  **** 				case ST_MSG_SIZE_1:
 629:stk500boot.c  **** 					msgLength		=	c<<8;
 816               		.loc 1 629 0
 817 02dc 792F      		mov r23,r25
 818 02de 60E0      		ldi r22,0
 819               	.LVL107:
 630:stk500boot.c  **** 					msgParseState	=	ST_MSG_SIZE_2;
 631:stk500boot.c  **** 					checksum		^=	c;
 820               		.loc 1 631 0
 821 02e0 7926      		eor r7,r25
 822               	.LVL108:
 630:stk500boot.c  **** 					msgParseState	=	ST_MSG_SIZE_2;
 823               		.loc 1 630 0
 824 02e2 83E0      		ldi r24,lo8(3)
 632:stk500boot.c  **** 					break;
 825               		.loc 1 632 0
 826 02e4 00C0      		rjmp .L66
 827               	.LVL109:
 828               	.L42:
 633:stk500boot.c  **** 
 634:stk500boot.c  **** 				case ST_MSG_SIZE_2:
 635:stk500boot.c  **** 					msgLength		|=	c;
 829               		.loc 1 635 0
 830 02e6 692B      		or r22,r25
 831               	.LVL110:
 636:stk500boot.c  **** 					msgParseState	=	ST_GET_TOKEN;
 637:stk500boot.c  **** 					checksum		^=	c;
 832               		.loc 1 637 0
 833 02e8 7926      		eor r7,r25
 834               	.LVL111:
 636:stk500boot.c  **** 					msgParseState	=	ST_GET_TOKEN;
 835               		.loc 1 636 0
 836 02ea 84E0      		ldi r24,lo8(4)
 638:stk500boot.c  **** 					break;
 837               		.loc 1 638 0
 838 02ec 00C0      		rjmp .L66
 839               	.LVL112:
 840               	.L43:
 639:stk500boot.c  **** 
 640:stk500boot.c  **** 				case ST_GET_TOKEN:
 641:stk500boot.c  **** 					if ( c == TOKEN )
 841               		.loc 1 641 0
 842 02ee 9E30      		cpi r25,lo8(14)
 843 02f0 01F0      		breq .+2
 844 02f2 00C0      		rjmp .L109
 845               	.LVL113:
 642:stk500boot.c  **** 					{
 643:stk500boot.c  **** 						msgParseState	=	ST_GET_DATA;
 644:stk500boot.c  **** 						checksum		^=	c;
 846               		.loc 1 644 0
 847 02f4 7926      		eor r7,r25
 848               	.LVL114:
 645:stk500boot.c  **** 						ii				=	0;
 849               		.loc 1 645 0
 850 02f6 212C      		mov r2,__zero_reg__
 851 02f8 312C      		mov r3,__zero_reg__
 643:stk500boot.c  **** 						msgParseState	=	ST_GET_DATA;
 852               		.loc 1 643 0
 853 02fa 85E0      		ldi r24,lo8(5)
 854 02fc 00C0      		rjmp .L66
 855               	.LVL115:
 856               	.L44:
 646:stk500boot.c  **** 					}
 647:stk500boot.c  **** 					else
 648:stk500boot.c  **** 					{
 649:stk500boot.c  **** 						msgParseState	=	ST_START;
 650:stk500boot.c  **** 					}
 651:stk500boot.c  **** 					break;
 652:stk500boot.c  **** 
 653:stk500boot.c  **** 				case ST_GET_DATA:
 654:stk500boot.c  **** 					msgBuffer[ii++]	=	c;
 857               		.loc 1 654 0
 858 02fe E1E0      		ldi r30,lo8(1)
 859 0300 F0E0      		ldi r31,0
 860 0302 EC0F      		add r30,r28
 861 0304 FD1F      		adc r31,r29
 862 0306 E20D      		add r30,r2
 863 0308 F31D      		adc r31,r3
 864 030a 9083      		st Z,r25
 865 030c AFEF      		ldi r26,-1
 866 030e 2A1A      		sub r2,r26
 867 0310 3A0A      		sbc r3,r26
 868               	.LVL116:
 655:stk500boot.c  **** 					checksum		^=	c;
 869               		.loc 1 655 0
 870 0312 7926      		eor r7,r25
 871               	.LVL117:
 656:stk500boot.c  **** 					if (ii == msgLength )
 872               		.loc 1 656 0
 873 0314 2616      		cp r2,r22
 874 0316 3706      		cpc r3,r23
 875 0318 01F0      		breq .+2
 876 031a 00C0      		rjmp .L66
 877 031c 00C0      		rjmp .L108
 878               	.LVL118:
 879               	.L45:
 657:stk500boot.c  **** 					{
 658:stk500boot.c  **** 						msgParseState	=	ST_GET_CHECK;
 659:stk500boot.c  **** 					}
 660:stk500boot.c  **** 					break;
 661:stk500boot.c  **** 
 662:stk500boot.c  **** 				case ST_GET_CHECK:
 663:stk500boot.c  **** 					if ( c == checksum )
 880               		.loc 1 663 0
 881 031e 9711      		cpse r25,r7
 882 0320 00C0      		rjmp .L109
 883               	.L67:
 664:stk500boot.c  **** 					{
 665:stk500boot.c  **** 						msgParseState	=	ST_PROCESS;
 666:stk500boot.c  **** 					}
 667:stk500boot.c  **** 					else
 668:stk500boot.c  **** 					{
 669:stk500boot.c  **** 						msgParseState	=	ST_START;
 670:stk500boot.c  **** 					}
 671:stk500boot.c  **** 					break;
 672:stk500boot.c  **** 				}	//	switch
 673:stk500boot.c  **** 			}	//	while(msgParseState)
 674:stk500boot.c  **** 
 675:stk500boot.c  **** 			/*
 676:stk500boot.c  **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
 677:stk500boot.c  **** 			 */
 678:stk500boot.c  **** 
 679:stk500boot.c  **** 			switch (msgBuffer[0]){
 884               		.loc 1 679 0
 885 0322 E981      		ldd r30,Y+1
 886 0324 E331      		cpi r30,lo8(19)
 887 0326 01F4      		brne .+2
 888 0328 00C0      		rjmp .L56
 889 032a 00F4      		brsh .L63
 890 032c E630      		cpi r30,lo8(6)
 891 032e 01F4      		brne .+2
 892 0330 00C0      		rjmp .L53
 893 0332 00F4      		brsh .L64
 894 0334 E230      		cpi r30,lo8(2)
 895 0336 01F4      		brne .+2
 896 0338 00C0      		rjmp .L184
 897 033a E330      		cpi r30,lo8(3)
 898 033c 01F4      		brne .+2
 899 033e 00C0      		rjmp .L52
 900 0340 E130      		cpi r30,lo8(1)
 901 0342 01F0      		breq .+2
 902 0344 00C0      		rjmp .L49
 903 0346 00C0      		rjmp .L50
 904               	.L64:
 905 0348 E131      		cpi r30,lo8(17)
 906 034a 01F4      		brne .+2
 907 034c 00C0      		rjmp .L54
 908 034e 00F0      		brlo .+2
 909 0350 00C0      		rjmp .L55
 910 0352 E031      		cpi r30,lo8(16)
 911 0354 01F0      		breq .+2
 912 0356 00C0      		rjmp .L49
 913 0358 00C0      		rjmp .L184
 914               	.L63:
 915 035a E831      		cpi r30,lo8(24)
 916 035c 01F4      		brne .+2
 917 035e 00C0      		rjmp .L58
 918 0360 00F4      		brsh .L65
 919 0362 E531      		cpi r30,lo8(21)
 920 0364 01F4      		brne .+2
 921 0366 00C0      		rjmp .L56
 922 0368 00F4      		brsh .+2
 923 036a 00C0      		rjmp .L57
 924 036c E631      		cpi r30,lo8(22)
 925 036e 01F0      		breq .+2
 926 0370 00C0      		rjmp .L49
 927 0372 00C0      		rjmp .L57
 928               	.L65:
 929 0374 EA31      		cpi r30,lo8(26)
 930 0376 01F4      		brne .+2
 931 0378 00C0      		rjmp .L60
 932 037a 00F4      		brsh .+2
 933 037c 00C0      		rjmp .L59
 934 037e EB31      		cpi r30,lo8(27)
 935 0380 01F4      		brne .+2
 936 0382 00C0      		rjmp .L61
 937 0384 ED31      		cpi r30,lo8(29)
 938 0386 01F0      		breq .+2
 939 0388 00C0      		rjmp .L49
 940 038a 00C0      		rjmp .L62
 941               	.L175:
 942               	.LVL119:
 592:stk500boot.c  **** 			while ( msgParseState != ST_PROCESS )
 943               		.loc 1 592 0 discriminator 1
 944 038c 8730      		cpi r24,lo8(7)
 945 038e 01F0      		breq .L67
 946 0390 00C0      		rjmp .L66
 947               	.LVL120:
 948               	.L62:
 949               	.LBB82:
 680:stk500boot.c  **** 			case CMD_SPI_MULTI:
 681:stk500boot.c  **** 			{
 682:stk500boot.c  **** 				unsigned char answerByte;
 683:stk500boot.c  **** 				unsigned char flag=0;
 684:stk500boot.c  **** 
 685:stk500boot.c  **** 				if ( msgBuffer[4]== 0x30 )
 950               		.loc 1 685 0
 951 0392 ED80      		ldd r14,Y+5
 952 0394 E0E3      		ldi r30,lo8(48)
 953 0396 EE12      		cpse r14,r30
 954 0398 00C0      		rjmp .L110
 955               	.LBB83:
 686:stk500boot.c  **** 				{
 687:stk500boot.c  **** 					unsigned char signatureIndex = msgBuffer[6];
 956               		.loc 1 687 0
 957 039a 8F81      		ldd r24,Y+7
 958               	.LVL121:
 688:stk500boot.c  **** 
 689:stk500boot.c  **** 					if ( signatureIndex == 0 ){
 959               		.loc 1 689 0
 960 039c 8111      		cpse r24,__zero_reg__
 961 039e 00C0      		rjmp .L69
 690:stk500boot.c  **** 						draw_line(0,LOADING_Y,128);
 962               		.loc 1 690 0
 963 03a0 87E3      		ldi r24,lo8(55)
 964               	.LVL122:
 965 03a2 C85D      		subi r28,lo8(-296)
 966 03a4 DE4F      		sbci r29,hi8(-296)
 967 03a6 2883      		st Y,r18
 968 03a8 C852      		subi r28,lo8(296)
 969 03aa D140      		sbci r29,hi8(296)
 970 03ac C75D      		subi r28,lo8(-297)
 971 03ae DE4F      		sbci r29,hi8(-297)
 972 03b0 3883      		st Y,r19
 973 03b2 C952      		subi r28,lo8(297)
 974 03b4 D140      		sbci r29,hi8(297)
 975 03b6 C65D      		subi r28,lo8(-298)
 976 03b8 DE4F      		sbci r29,hi8(-298)
 977 03ba 4883      		st Y,r20
 978 03bc CA52      		subi r28,lo8(298)
 979 03be D140      		sbci r29,hi8(298)
 980 03c0 C55D      		subi r28,lo8(-299)
 981 03c2 DE4F      		sbci r29,hi8(-299)
 982 03c4 5883      		st Y,r21
 983 03c6 CB52      		subi r28,lo8(299)
 984 03c8 D140      		sbci r29,hi8(299)
 985 03ca 0E94 0000 		call draw_line.constprop.0
 986               	.LVL123:
 691:stk500boot.c  **** 						draw_line(0,LOADING_Y+4,128);
 987               		.loc 1 691 0
 988 03ce 8BE3      		ldi r24,lo8(59)
 989 03d0 0E94 0000 		call draw_line.constprop.0
 990               	.LVL124:
 692:stk500boot.c  **** 						// top optimize it written by hand:
 693:stk500boot.c  **** 						send_command(0x15);
 991               		.loc 1 693 0
 992 03d4 85E1      		ldi r24,lo8(21)
 993 03d6 0E94 0000 		call send_command
 994               	.LVL125:
 694:stk500boot.c  **** 						send_command(0);
 995               		.loc 1 694 0
 996 03da 80E0      		ldi r24,0
 997 03dc 0E94 0000 		call send_command
 998               	.LVL126:
 695:stk500boot.c  **** 						send_command(0);
 999               		.loc 1 695 0
 1000 03e0 80E0      		ldi r24,0
 1001 03e2 0E94 0000 		call send_command
 1002               	.LVL127:
 696:stk500boot.c  **** 						send_command(0x75);
 1003               		.loc 1 696 0
 1004 03e6 85E7      		ldi r24,lo8(117)
 1005 03e8 0E94 0000 		call send_command
 1006               	.LVL128:
 697:stk500boot.c  **** 						send_command(LOADING_Y+1);
 1007               		.loc 1 697 0
 1008 03ec 88E3      		ldi r24,lo8(56)
 1009 03ee 0E94 0000 		call send_command
 1010               	.LVL129:
 698:stk500boot.c  **** 						send_command(LOADING_Y+3);
 1011               		.loc 1 698 0
 1012 03f2 8AE3      		ldi r24,lo8(58)
 1013 03f4 0E94 0000 		call send_command
 1014               	.LVL130:
 699:stk500boot.c  **** 						send_char(0xf0);
 1015               		.loc 1 699 0
 1016 03f8 80EF      		ldi r24,lo8(-16)
 1017 03fa 0E94 0000 		call send_char
 1018               	.LVL131:
 700:stk500boot.c  **** 						send_char(0xf0);
 1019               		.loc 1 700 0
 1020 03fe 80EF      		ldi r24,lo8(-16)
 1021 0400 0E94 0000 		call send_char
 1022               	.LVL132:
 701:stk500boot.c  **** 						send_char(0xf0);
 1023               		.loc 1 701 0
 1024 0404 80EF      		ldi r24,lo8(-16)
 1025 0406 0E94 0000 		call send_char
 1026               	.LVL133:
 702:stk500boot.c  **** 
 703:stk500boot.c  **** 						send_command(0x15);
 1027               		.loc 1 703 0
 1028 040a 85E1      		ldi r24,lo8(21)
 1029 040c 0E94 0000 		call send_command
 1030               	.LVL134:
 704:stk500boot.c  **** 						send_command(63);
 1031               		.loc 1 704 0
 1032 0410 8FE3      		ldi r24,lo8(63)
 1033 0412 0E94 0000 		call send_command
 1034               	.LVL135:
 705:stk500boot.c  **** 						send_command(64);
 1035               		.loc 1 705 0
 1036 0416 80E4      		ldi r24,lo8(64)
 1037 0418 0E94 0000 		call send_command
 1038               	.LVL136:
 706:stk500boot.c  **** 						send_command(0x75);
 1039               		.loc 1 706 0
 1040 041c 85E7      		ldi r24,lo8(117)
 1041 041e 0E94 0000 		call send_command
 1042               	.LVL137:
 707:stk500boot.c  **** 						send_command(LOADING_Y+1);
 1043               		.loc 1 707 0
 1044 0422 88E3      		ldi r24,lo8(56)
 1045 0424 0E94 0000 		call send_command
 1046               	.LVL138:
 708:stk500boot.c  **** 						send_command(LOADING_Y+3);
 1047               		.loc 1 708 0
 1048 0428 8AE3      		ldi r24,lo8(58)
 1049 042a 0E94 0000 		call send_command
 1050               	.LVL139:
 709:stk500boot.c  **** 						send_char(0x0f);
 1051               		.loc 1 709 0
 1052 042e 8FE0      		ldi r24,lo8(15)
 1053 0430 0E94 0000 		call send_char
 1054               	.LVL140:
 710:stk500boot.c  **** 						send_char(0x0f);
 1055               		.loc 1 710 0
 1056 0434 8FE0      		ldi r24,lo8(15)
 1057 0436 0E94 0000 		call send_char
 1058               	.LVL141:
 711:stk500boot.c  **** 						send_char(0x0f);
 1059               		.loc 1 711 0
 1060 043a 8FE0      		ldi r24,lo8(15)
 1061 043c 0E94 0000 		call send_char
 1062               	.LVL142:
 375:stk500boot.c  **** 	unsigned char x=15;
 1063               		.loc 1 375 0
 1064 0440 0FE0      		ldi r16,lo8(15)
 379:stk500boot.c  **** 	for(a=0;a<9;a++){
 1065               		.loc 1 379 0
 1066 0442 F12C      		mov r15,__zero_reg__
 381:stk500boot.c  **** 			buchstabe=5;
 1067               		.loc 1 381 0
 1068 0444 95E0      		ldi r25,lo8(5)
 1069 0446 C85D      		subi r28,lo8(-296)
 1070 0448 DE4F      		sbci r29,hi8(-296)
 1071 044a 2881      		ld r18,Y
 1072 044c C852      		subi r28,lo8(296)
 1073 044e D140      		sbci r29,hi8(296)
 1074 0450 C75D      		subi r28,lo8(-297)
 1075 0452 DE4F      		sbci r29,hi8(-297)
 1076 0454 3881      		ld r19,Y
 1077 0456 C952      		subi r28,lo8(297)
 1078 0458 D140      		sbci r29,hi8(297)
 1079 045a C65D      		subi r28,lo8(-298)
 1080 045c DE4F      		sbci r29,hi8(-298)
 1081 045e 4881      		ld r20,Y
 1082 0460 CA52      		subi r28,lo8(298)
 1083 0462 D140      		sbci r29,hi8(298)
 1084 0464 C55D      		subi r28,lo8(-299)
 1085 0466 DE4F      		sbci r29,hi8(-299)
 1086 0468 5881      		ld r21,Y
 1087 046a CB52      		subi r28,lo8(299)
 1088 046c D140      		sbci r29,hi8(299)
 1089 046e 00C0      		rjmp .L70
 1090               	.LVL143:
 1091               	.L79:
 1092               	.LBB84:
 1093               	.LBB85:
 382:stk500boot.c  **** 		} else if(a==1){ // P
 1094               		.loc 1 382 0
 1095 0470 8130      		cpi r24,lo8(1)
 1096 0472 01F0      		breq .L111
 384:stk500boot.c  **** 		} else if(a==2 || a==3){ // E
 1097               		.loc 1 384 0
 1098 0474 9F2D      		mov r25,r15
 1099 0476 9150      		subi r25,lo8(-(-1))
 1100 0478 9230      		cpi r25,lo8(2)
 1101 047a 00F0      		brlo .L112
 386:stk500boot.c  **** 		} else if(a==4){ // D
 1102               		.loc 1 386 0
 1103 047c 8430      		cpi r24,lo8(4)
 1104 047e 01F0      		breq .L113
 388:stk500boot.c  **** 		} else if(a==5 || a==8){ // O
 1105               		.loc 1 388 0
 1106 0480 8530      		cpi r24,lo8(5)
 1107 0482 01F0      		breq .L115
 1108 0484 8830      		cpi r24,lo8(8)
 1109 0486 01F0      		breq .L115
 390:stk500boot.c  **** 		} else if(a==6){ // I
 1110               		.loc 1 390 0
 1111 0488 8630      		cpi r24,lo8(6)
 1112 048a 01F0      		breq .L116
 393:stk500boot.c  **** 			buchstabe=3;
 1113               		.loc 1 393 0
 1114 048c 93E0      		ldi r25,lo8(3)
 1115 048e 00C0      		rjmp .L71
 1116               	.L111:
 383:stk500boot.c  **** 			buchstabe=6;
 1117               		.loc 1 383 0
 1118 0490 96E0      		ldi r25,lo8(6)
 1119 0492 00C0      		rjmp .L71
 1120               	.L112:
 385:stk500boot.c  **** 			buchstabe=0;
 1121               		.loc 1 385 0
 1122 0494 90E0      		ldi r25,0
 1123 0496 00C0      		rjmp .L71
 1124               	.L113:
 387:stk500boot.c  **** 			buchstabe=1;
 1125               		.loc 1 387 0
 1126 0498 91E0      		ldi r25,lo8(1)
 1127 049a 00C0      		rjmp .L71
 1128               	.L115:
 389:stk500boot.c  **** 			buchstabe=4;
 1129               		.loc 1 389 0
 1130 049c 94E0      		ldi r25,lo8(4)
 1131 049e 00C0      		rjmp .L71
 1132               	.L116:
 391:stk500boot.c  **** 			buchstabe=2;
 1133               		.loc 1 391 0
 1134 04a0 92E0      		ldi r25,lo8(2)
 1135               	.L71:
 379:stk500boot.c  **** 	for(a=0;a<9;a++){
 1136               		.loc 1 379 0
 1137 04a2 F82E      		mov r15,r24
 1138               	.LVL144:
 1139               	.L70:
 396:stk500boot.c  **** 		send_command(0x15);
 1140               		.loc 1 396 0
 1141 04a4 85E1      		ldi r24,lo8(21)
 1142 04a6 C85D      		subi r28,lo8(-296)
 1143 04a8 DE4F      		sbci r29,hi8(-296)
 1144 04aa 2883      		st Y,r18
 1145 04ac C852      		subi r28,lo8(296)
 1146 04ae D140      		sbci r29,hi8(296)
 1147 04b0 C75D      		subi r28,lo8(-297)
 1148 04b2 DE4F      		sbci r29,hi8(-297)
 1149 04b4 3883      		st Y,r19
 1150 04b6 C952      		subi r28,lo8(297)
 1151 04b8 D140      		sbci r29,hi8(297)
 1152 04ba C65D      		subi r28,lo8(-298)
 1153 04bc DE4F      		sbci r29,hi8(-298)
 1154 04be 4883      		st Y,r20
 1155 04c0 CA52      		subi r28,lo8(298)
 1156 04c2 D140      		sbci r29,hi8(298)
 1157 04c4 C55D      		subi r28,lo8(-299)
 1158 04c6 DE4F      		sbci r29,hi8(-299)
 1159 04c8 5883      		st Y,r21
 1160 04ca CB52      		subi r28,lo8(299)
 1161 04cc D140      		sbci r29,hi8(299)
 1162 04ce CA5D      		subi r28,lo8(-294)
 1163 04d0 DE4F      		sbci r29,hi8(-294)
 1164 04d2 9883      		st Y,r25
 1165 04d4 C652      		subi r28,lo8(294)
 1166 04d6 D140      		sbci r29,hi8(294)
 1167 04d8 0E94 0000 		call send_command
 1168               	.LVL145:
 397:stk500boot.c  **** 		send_command(x);
 1169               		.loc 1 397 0
 1170 04dc 802F      		mov r24,r16
 1171 04de 0E94 0000 		call send_command
 1172               	.LVL146:
 398:stk500boot.c  **** 		send_command(x+2); // buchstaben sind 5px breit + spacer
 1173               		.loc 1 398 0
 1174 04e2 802F      		mov r24,r16
 1175 04e4 8E5F      		subi r24,lo8(-(2))
 1176 04e6 0E94 0000 		call send_command
 1177               	.LVL147:
 399:stk500boot.c  **** 		send_command(0x75);
 1178               		.loc 1 399 0
 1179 04ea 85E7      		ldi r24,lo8(117)
 1180 04ec 0E94 0000 		call send_command
 1181               	.LVL148:
 400:stk500boot.c  **** 		send_command(y);
 1182               		.loc 1 400 0
 1183 04f0 8FE2      		ldi r24,lo8(47)
 1184 04f2 0E94 0000 		call send_command
 1185               	.LVL149:
 401:stk500boot.c  **** 		send_command(y+5); // und 5 px hoch
 1186               		.loc 1 401 0
 1187 04f6 84E3      		ldi r24,lo8(52)
 1188 04f8 0E94 0000 		call send_command
 1189               	.LVL150:
 403:stk500boot.c  **** 		buchstabe=buchstabe*6;
 1190               		.loc 1 403 0
 1191 04fc CA5D      		subi r28,lo8(-294)
 1192 04fe DE4F      		sbci r29,hi8(-294)
 1193 0500 9881      		ld r25,Y
 1194 0502 C652      		subi r28,lo8(294)
 1195 0504 D140      		sbci r29,hi8(294)
 1196 0506 C92E      		mov r12,r25
 1197 0508 CC0C      		lsl r12
 1198 050a C90E      		add r12,r25
 1199 050c CC0C      		lsl r12
 1200               	.LVL151:
 467:stk500boot.c  **** int main(void)
 1201               		.loc 1 467 0
 1202 050e 86E0      		ldi r24,lo8(6)
 1203 0510 D82E      		mov r13,r24
 1204 0512 DC0C      		add r13,r12
 1205 0514 C55D      		subi r28,lo8(-299)
 1206 0516 DE4F      		sbci r29,hi8(-299)
 1207 0518 5881      		ld r21,Y
 1208 051a CB52      		subi r28,lo8(299)
 1209 051c D140      		sbci r29,hi8(299)
 1210 051e C65D      		subi r28,lo8(-298)
 1211 0520 DE4F      		sbci r29,hi8(-298)
 1212 0522 4881      		ld r20,Y
 1213 0524 CA52      		subi r28,lo8(298)
 1214 0526 D140      		sbci r29,hi8(298)
 1215 0528 C75D      		subi r28,lo8(-297)
 1216 052a DE4F      		sbci r29,hi8(-297)
 1217 052c 3881      		ld r19,Y
 1218 052e C952      		subi r28,lo8(297)
 1219 0530 D140      		sbci r29,hi8(297)
 1220 0532 C85D      		subi r28,lo8(-296)
 1221 0534 DE4F      		sbci r29,hi8(-296)
 1222 0536 2881      		ld r18,Y
 1223 0538 C852      		subi r28,lo8(296)
 1224 053a D140      		sbci r29,hi8(296)
 1225               	.LVL152:
 1226               	.L78:
 405:stk500boot.c  **** 			data=speedoino_data[buchstabe];
 1227               		.loc 1 405 0
 1228 053c EC2D      		mov r30,r12
 1229 053e F0E0      		ldi r31,0
 1230 0540 E050      		subi r30,lo8(-(speedoino_data))
 1231 0542 F040      		sbci r31,hi8(-(speedoino_data))
 1232 0544 7080      		ld r7,Z
 1233               	.LVL153:
 406:stk500boot.c  **** 			buchstabe++;
 1234               		.loc 1 406 0
 1235 0546 C394      		inc r12
 1236               	.LVL154:
 409:stk500boot.c  **** 			if(data&0b10000000)	send_me|=0xf0;
 1237               		.loc 1 409 0
 1238 0548 77FC      		sbrc r7,7
 1239 054a 00C0      		rjmp .L117
 408:stk500boot.c  **** 			send_me=0x00;
 1240               		.loc 1 408 0
 1241 054c 80E0      		ldi r24,0
 1242 054e 00C0      		rjmp .L72
 1243               	.L117:
 409:stk500boot.c  **** 			if(data&0b10000000)	send_me|=0xf0;
 1244               		.loc 1 409 0
 1245 0550 80EF      		ldi r24,lo8(-16)
 1246               	.L72:
 1247               	.LVL155:
 410:stk500boot.c  **** 			if(data&0b01000000)	send_me|=0x0f;
 1248               		.loc 1 410 0
 1249 0552 76FC      		sbrc r7,6
 1250 0554 8F60      		ori r24,lo8(15)
 1251               	.LVL156:
 1252               	.L73:
 411:stk500boot.c  **** 			send_char(send_me);
 1253               		.loc 1 411 0
 1254 0556 C85D      		subi r28,lo8(-296)
 1255 0558 DE4F      		sbci r29,hi8(-296)
 1256 055a 2883      		st Y,r18
 1257 055c C852      		subi r28,lo8(296)
 1258 055e D140      		sbci r29,hi8(296)
 1259 0560 C75D      		subi r28,lo8(-297)
 1260 0562 DE4F      		sbci r29,hi8(-297)
 1261 0564 3883      		st Y,r19
 1262 0566 C952      		subi r28,lo8(297)
 1263 0568 D140      		sbci r29,hi8(297)
 1264 056a C65D      		subi r28,lo8(-298)
 1265 056c DE4F      		sbci r29,hi8(-298)
 1266 056e 4883      		st Y,r20
 1267 0570 CA52      		subi r28,lo8(298)
 1268 0572 D140      		sbci r29,hi8(298)
 1269 0574 C55D      		subi r28,lo8(-299)
 1270 0576 DE4F      		sbci r29,hi8(-299)
 1271 0578 5883      		st Y,r21
 1272 057a CB52      		subi r28,lo8(299)
 1273 057c D140      		sbci r29,hi8(299)
 1274 057e 0E94 0000 		call send_char
 1275               	.LVL157:
 414:stk500boot.c  **** 			if(data&0b00100000)	send_me|=0xf0;
 1276               		.loc 1 414 0
 1277 0582 C85D      		subi r28,lo8(-296)
 1278 0584 DE4F      		sbci r29,hi8(-296)
 1279 0586 2881      		ld r18,Y
 1280 0588 C852      		subi r28,lo8(296)
 1281 058a D140      		sbci r29,hi8(296)
 1282 058c C75D      		subi r28,lo8(-297)
 1283 058e DE4F      		sbci r29,hi8(-297)
 1284 0590 3881      		ld r19,Y
 1285 0592 C952      		subi r28,lo8(297)
 1286 0594 D140      		sbci r29,hi8(297)
 1287 0596 C65D      		subi r28,lo8(-298)
 1288 0598 DE4F      		sbci r29,hi8(-298)
 1289 059a 4881      		ld r20,Y
 1290 059c CA52      		subi r28,lo8(298)
 1291 059e D140      		sbci r29,hi8(298)
 1292 05a0 C55D      		subi r28,lo8(-299)
 1293 05a2 DE4F      		sbci r29,hi8(-299)
 1294 05a4 5881      		ld r21,Y
 1295 05a6 CB52      		subi r28,lo8(299)
 1296 05a8 D140      		sbci r29,hi8(299)
 1297 05aa 75FE      		sbrs r7,5
 1298 05ac 00C0      		rjmp .L118
 1299 05ae 80EF      		ldi r24,lo8(-16)
 1300 05b0 00C0      		rjmp .L74
 1301               	.L118:
 413:stk500boot.c  **** 			send_me=0x00;
 1302               		.loc 1 413 0
 1303 05b2 80E0      		ldi r24,0
 1304               	.L74:
 1305               	.LVL158:
 415:stk500boot.c  **** 			if(data&0b00010000)	send_me|=0x0f;
 1306               		.loc 1 415 0
 1307 05b4 74FC      		sbrc r7,4
 1308 05b6 8F60      		ori r24,lo8(15)
 1309               	.LVL159:
 1310               	.L75:
 416:stk500boot.c  **** 			send_char(send_me);
 1311               		.loc 1 416 0
 1312 05b8 C85D      		subi r28,lo8(-296)
 1313 05ba DE4F      		sbci r29,hi8(-296)
 1314 05bc 2883      		st Y,r18
 1315 05be C852      		subi r28,lo8(296)
 1316 05c0 D140      		sbci r29,hi8(296)
 1317 05c2 C75D      		subi r28,lo8(-297)
 1318 05c4 DE4F      		sbci r29,hi8(-297)
 1319 05c6 3883      		st Y,r19
 1320 05c8 C952      		subi r28,lo8(297)
 1321 05ca D140      		sbci r29,hi8(297)
 1322 05cc C65D      		subi r28,lo8(-298)
 1323 05ce DE4F      		sbci r29,hi8(-298)
 1324 05d0 4883      		st Y,r20
 1325 05d2 CA52      		subi r28,lo8(298)
 1326 05d4 D140      		sbci r29,hi8(298)
 1327 05d6 C55D      		subi r28,lo8(-299)
 1328 05d8 DE4F      		sbci r29,hi8(-299)
 1329 05da 5883      		st Y,r21
 1330 05dc CB52      		subi r28,lo8(299)
 1331 05de D140      		sbci r29,hi8(299)
 1332 05e0 0E94 0000 		call send_char
 1333               	.LVL160:
 419:stk500boot.c  **** 			if(data&0b00001000)	send_me|=0xf0;
 1334               		.loc 1 419 0
 1335 05e4 C85D      		subi r28,lo8(-296)
 1336 05e6 DE4F      		sbci r29,hi8(-296)
 1337 05e8 2881      		ld r18,Y
 1338 05ea C852      		subi r28,lo8(296)
 1339 05ec D140      		sbci r29,hi8(296)
 1340 05ee C75D      		subi r28,lo8(-297)
 1341 05f0 DE4F      		sbci r29,hi8(-297)
 1342 05f2 3881      		ld r19,Y
 1343 05f4 C952      		subi r28,lo8(297)
 1344 05f6 D140      		sbci r29,hi8(297)
 1345 05f8 C65D      		subi r28,lo8(-298)
 1346 05fa DE4F      		sbci r29,hi8(-298)
 1347 05fc 4881      		ld r20,Y
 1348 05fe CA52      		subi r28,lo8(298)
 1349 0600 D140      		sbci r29,hi8(298)
 1350 0602 C55D      		subi r28,lo8(-299)
 1351 0604 DE4F      		sbci r29,hi8(-299)
 1352 0606 5881      		ld r21,Y
 1353 0608 CB52      		subi r28,lo8(299)
 1354 060a D140      		sbci r29,hi8(299)
 1355 060c 73FE      		sbrs r7,3
 1356 060e 00C0      		rjmp .L119
 1357 0610 80EF      		ldi r24,lo8(-16)
 1358 0612 00C0      		rjmp .L76
 1359               	.L119:
 418:stk500boot.c  **** 			send_me=0x00;
 1360               		.loc 1 418 0
 1361 0614 80E0      		ldi r24,0
 1362               	.L76:
 1363               	.LVL161:
 420:stk500boot.c  **** 			if(data&0b00000100)	send_me|=0x0f;
 1364               		.loc 1 420 0
 1365 0616 72FC      		sbrc r7,2
 1366 0618 8F60      		ori r24,lo8(15)
 1367               	.LVL162:
 1368               	.L77:
 421:stk500boot.c  **** 			send_char(send_me);
 1369               		.loc 1 421 0
 1370 061a C85D      		subi r28,lo8(-296)
 1371 061c DE4F      		sbci r29,hi8(-296)
 1372 061e 2883      		st Y,r18
 1373 0620 C852      		subi r28,lo8(296)
 1374 0622 D140      		sbci r29,hi8(296)
 1375 0624 C75D      		subi r28,lo8(-297)
 1376 0626 DE4F      		sbci r29,hi8(-297)
 1377 0628 3883      		st Y,r19
 1378 062a C952      		subi r28,lo8(297)
 1379 062c D140      		sbci r29,hi8(297)
 1380 062e C65D      		subi r28,lo8(-298)
 1381 0630 DE4F      		sbci r29,hi8(-298)
 1382 0632 4883      		st Y,r20
 1383 0634 CA52      		subi r28,lo8(298)
 1384 0636 D140      		sbci r29,hi8(298)
 1385 0638 C55D      		subi r28,lo8(-299)
 1386 063a DE4F      		sbci r29,hi8(-299)
 1387 063c 5883      		st Y,r21
 1388 063e CB52      		subi r28,lo8(299)
 1389 0640 D140      		sbci r29,hi8(299)
 1390 0642 0E94 0000 		call send_char
 1391               	.LVL163:
 404:stk500boot.c  **** 		for(zeile=0;zeile<6;zeile++){
 1392               		.loc 1 404 0
 1393 0646 C85D      		subi r28,lo8(-296)
 1394 0648 DE4F      		sbci r29,hi8(-296)
 1395 064a 2881      		ld r18,Y
 1396 064c C852      		subi r28,lo8(296)
 1397 064e D140      		sbci r29,hi8(296)
 1398 0650 C75D      		subi r28,lo8(-297)
 1399 0652 DE4F      		sbci r29,hi8(-297)
 1400 0654 3881      		ld r19,Y
 1401 0656 C952      		subi r28,lo8(297)
 1402 0658 D140      		sbci r29,hi8(297)
 1403 065a C65D      		subi r28,lo8(-298)
 1404 065c DE4F      		sbci r29,hi8(-298)
 1405 065e 4881      		ld r20,Y
 1406 0660 CA52      		subi r28,lo8(298)
 1407 0662 D140      		sbci r29,hi8(298)
 1408 0664 C55D      		subi r28,lo8(-299)
 1409 0666 DE4F      		sbci r29,hi8(-299)
 1410 0668 5881      		ld r21,Y
 1411 066a CB52      		subi r28,lo8(299)
 1412 066c D140      		sbci r29,hi8(299)
 1413 066e CD10      		cpse r12,r13
 1414 0670 00C0      		rjmp .L78
 424:stk500boot.c  **** 		x+=3;
 1415               		.loc 1 424 0
 1416 0672 0D5F      		subi r16,lo8(-(3))
 1417               	.LVL164:
 379:stk500boot.c  **** 	for(a=0;a<9;a++){
 1418               		.loc 1 379 0
 1419 0674 8F2D      		mov r24,r15
 1420 0676 8F5F      		subi r24,lo8(-(1))
 1421               	.LVL165:
 1422 0678 0A32      		cpi r16,lo8(42)
 1423 067a 01F0      		breq .+2
 1424 067c 00C0      		rjmp .L79
 712:stk500boot.c  **** 
 713:stk500boot.c  **** 						show_logo();
 714:stk500boot.c  **** 
 715:stk500boot.c  **** 						answerByte = (SIGNATURE_BYTES >>16) & 0x000000FF;
 1425               		.loc 1 715 0
 1426 067e 8EE1      		ldi r24,lo8(30)
 1427               	.LVL166:
 1428 0680 00C0      		rjmp .L68
 1429               	.LVL167:
 1430               	.L69:
 1431               	.LBE85:
 1432               	.LBE84:
 716:stk500boot.c  **** 					} else if ( signatureIndex == 1 ) {
 1433               		.loc 1 716 0
 1434 0682 8130      		cpi r24,lo8(1)
 1435 0684 01F4      		brne .L120
 717:stk500boot.c  **** 						answerByte = (SIGNATURE_BYTES >> 8) & 0x000000FF;
 1436               		.loc 1 717 0
 1437 0686 88E9      		ldi r24,lo8(-104)
 1438               	.LVL168:
 1439 0688 00C0      		rjmp .L68
 1440               	.LVL169:
 1441               	.L110:
 1442               	.LBE83:
 718:stk500boot.c  **** 					} else {
 719:stk500boot.c  **** 						answerByte = SIGNATURE_BYTES & 0x000000FF;
 720:stk500boot.c  **** 					};
 721:stk500boot.c  **** 				}
 722:stk500boot.c  **** 				else if ( msgBuffer[4] & 0x50 )
 723:stk500boot.c  **** 				{
 724:stk500boot.c  **** 					answerByte = 0; //read fuse/lock bits not implemented, return dummy value
 1443               		.loc 1 724 0
 1444 068a 80E0      		ldi r24,0
 1445 068c 00C0      		rjmp .L68
 1446               	.LVL170:
 1447               	.L120:
 1448               	.LBB86:
 719:stk500boot.c  **** 						answerByte = SIGNATURE_BYTES & 0x000000FF;
 1449               		.loc 1 719 0
 1450 068e 81E0      		ldi r24,lo8(1)
 1451               	.LVL171:
 1452               	.L68:
 1453               	.LBE86:
 725:stk500boot.c  **** 				}
 726:stk500boot.c  **** 				else
 727:stk500boot.c  **** 				{
 728:stk500boot.c  **** 					answerByte = 0; // for all others command are not implemented, return dummy value for AVRDUDE 
 729:stk500boot.c  **** 					// flag = 1; // Remark this line for AVRDUDE <Worapoht>
 730:stk500boot.c  **** 				}
 731:stk500boot.c  **** 				if ( !flag )
 732:stk500boot.c  **** 				{
 733:stk500boot.c  **** 					msgLength = 7;
 734:stk500boot.c  **** 					msgBuffer[1] = STATUS_CMD_OK;
 1454               		.loc 1 734 0
 1455 0690 1A82      		std Y+2,__zero_reg__
 735:stk500boot.c  **** 					msgBuffer[2] = 0;
 1456               		.loc 1 735 0
 1457 0692 1B82      		std Y+3,__zero_reg__
 736:stk500boot.c  **** 					msgBuffer[3] = msgBuffer[4];
 1458               		.loc 1 736 0
 1459 0694 EC82      		std Y+4,r14
 737:stk500boot.c  **** 					msgBuffer[4] = 0;
 1460               		.loc 1 737 0
 1461 0696 1D82      		std Y+5,__zero_reg__
 738:stk500boot.c  **** 					msgBuffer[5] = answerByte;
 1462               		.loc 1 738 0
 1463 0698 8E83      		std Y+6,r24
 739:stk500boot.c  **** 					msgBuffer[6] = STATUS_CMD_OK;
 1464               		.loc 1 739 0
 1465 069a 1F82      		std Y+7,__zero_reg__
 1466 069c 00E0      		ldi r16,0
 733:stk500boot.c  **** 					msgLength = 7;
 1467               		.loc 1 733 0
 1468 069e 67E0      		ldi r22,lo8(7)
 1469 06a0 70E0      		ldi r23,0
 1470 06a2 00C0      		rjmp .L80
 1471               	.LVL172:
 1472               	.L50:
 1473               	.LBE82:
 740:stk500boot.c  **** 				}
 741:stk500boot.c  **** 				// darf nicht in dem init kommen, sonst malen wir das jedes mal - bei jedem Startup, auch wenn 
 742:stk500boot.c  **** 
 743:stk500boot.c  **** 			}
 744:stk500boot.c  **** 			break;
 745:stk500boot.c  **** 
 746:stk500boot.c  **** 			case CMD_SIGN_ON:
 747:stk500boot.c  **** 				msgLength		=	11;
 748:stk500boot.c  **** 				msgBuffer[1] 	=	STATUS_CMD_OK;
 1474               		.loc 1 748 0
 1475 06a4 1A82      		std Y+2,__zero_reg__
 749:stk500boot.c  **** 				msgBuffer[2] 	=	8;
 1476               		.loc 1 749 0
 1477 06a6 88E0      		ldi r24,lo8(8)
 1478 06a8 8B83      		std Y+3,r24
 750:stk500boot.c  **** 				msgBuffer[3] 	=	'A';
 1479               		.loc 1 750 0
 1480 06aa 81E4      		ldi r24,lo8(65)
 1481 06ac 8C83      		std Y+4,r24
 751:stk500boot.c  **** 				msgBuffer[4] 	=	'V';
 1482               		.loc 1 751 0
 1483 06ae 86E5      		ldi r24,lo8(86)
 1484 06b0 8D83      		std Y+5,r24
 752:stk500boot.c  **** 				msgBuffer[5] 	=	'R';
 1485               		.loc 1 752 0
 1486 06b2 82E5      		ldi r24,lo8(82)
 1487 06b4 8E83      		std Y+6,r24
 753:stk500boot.c  **** 				msgBuffer[6] 	=	'I';
 1488               		.loc 1 753 0
 1489 06b6 89E4      		ldi r24,lo8(73)
 1490 06b8 8F83      		std Y+7,r24
 754:stk500boot.c  **** 				msgBuffer[7] 	=	'S';
 1491               		.loc 1 754 0
 1492 06ba 83E5      		ldi r24,lo8(83)
 1493 06bc 8887      		std Y+8,r24
 755:stk500boot.c  **** 				msgBuffer[8] 	=	'P';
 1494               		.loc 1 755 0
 1495 06be 80E5      		ldi r24,lo8(80)
 1496 06c0 8987      		std Y+9,r24
 756:stk500boot.c  **** 				msgBuffer[9] 	=	'_';
 1497               		.loc 1 756 0
 1498 06c2 8FE5      		ldi r24,lo8(95)
 1499 06c4 8A87      		std Y+10,r24
 757:stk500boot.c  **** 				msgBuffer[10]	=	'2';
 1500               		.loc 1 757 0
 1501 06c6 82E3      		ldi r24,lo8(50)
 1502 06c8 8B87      		std Y+11,r24
 758:stk500boot.c  **** 				break;
 1503               		.loc 1 758 0
 1504 06ca 00E0      		ldi r16,0
 747:stk500boot.c  **** 				msgLength		=	11;
 1505               		.loc 1 747 0
 1506 06cc 6BE0      		ldi r22,lo8(11)
 1507 06ce 70E0      		ldi r23,0
 1508               		.loc 1 758 0
 1509 06d0 00C0      		rjmp .L80
 1510               	.LVL173:
 1511               	.L52:
 1512 06d2 EA81      		ldd r30,Y+2
 1513 06d4 E059      		subi r30,lo8(-(112))
 1514 06d6 E330      		cpi r30,lo8(3)
 1515 06d8 00F4      		brsh .L121
 1516 06da F0E0      		ldi r31,0
 1517 06dc E050      		subi r30,lo8(-(CSWTCH.21))
 1518 06de F040      		sbci r31,hi8(-(CSWTCH.21))
 1519 06e0 8081      		ld r24,Z
 1520 06e2 00C0      		rjmp .L81
 1521               	.L121:
 1522               	.LBB87:
 759:stk500boot.c  **** 
 760:stk500boot.c  **** 			case CMD_GET_PARAMETER:
 761:stk500boot.c  **** 			{
 762:stk500boot.c  **** 				unsigned char value;
 763:stk500boot.c  **** 
 764:stk500boot.c  **** 				switch(msgBuffer[1])
 1523               		.loc 1 764 0
 1524 06e4 80E0      		ldi r24,0
 1525               	.L81:
 1526               	.LVL174:
 765:stk500boot.c  **** 				{
 766:stk500boot.c  **** 				case PARAM_BUILD_NUMBER_LOW:
 767:stk500boot.c  **** 					value	=	CONFIG_PARAM_BUILD_NUMBER_LOW;
 768:stk500boot.c  **** 					break;
 769:stk500boot.c  **** 				case PARAM_BUILD_NUMBER_HIGH:
 770:stk500boot.c  **** 					value	=	CONFIG_PARAM_BUILD_NUMBER_HIGH;
 771:stk500boot.c  **** 					break;
 772:stk500boot.c  **** 				case PARAM_HW_VER:
 773:stk500boot.c  **** 					value	=	CONFIG_PARAM_HW_VER;
 774:stk500boot.c  **** 					break;
 775:stk500boot.c  **** 				case PARAM_SW_MAJOR:
 776:stk500boot.c  **** 					value	=	CONFIG_PARAM_SW_MAJOR;
 777:stk500boot.c  **** 					break;
 778:stk500boot.c  **** 				case PARAM_SW_MINOR:
 779:stk500boot.c  **** 					value	=	CONFIG_PARAM_SW_MINOR;
 780:stk500boot.c  **** 					break;
 781:stk500boot.c  **** 				default:
 782:stk500boot.c  **** 					value	=	0;
 783:stk500boot.c  **** 					break;
 784:stk500boot.c  **** 				}
 785:stk500boot.c  **** 				msgLength		=	3;
 786:stk500boot.c  **** 				msgBuffer[1]	=	STATUS_CMD_OK;
 1527               		.loc 1 786 0
 1528 06e6 1A82      		std Y+2,__zero_reg__
 787:stk500boot.c  **** 				msgBuffer[2]	=	value;
 1529               		.loc 1 787 0
 1530 06e8 8B83      		std Y+3,r24
 1531 06ea 00C0      		rjmp .L179
 1532               	.LVL175:
 1533               	.L54:
 1534               	.LBE87:
 788:stk500boot.c  **** 			}
 789:stk500boot.c  **** 			break;
 790:stk500boot.c  **** 
 791:stk500boot.c  **** 			case CMD_LEAVE_PROGMODE_ISP:
 792:stk500boot.c  **** 				isLeave			=	1;
 793:stk500boot.c  **** 				msgLength		=	2;
 794:stk500boot.c  **** 				msgBuffer[1]	=	STATUS_CMD_OK;
 1535               		.loc 1 794 0
 1536 06ec 1A82      		std Y+2,__zero_reg__
 792:stk500boot.c  **** 				isLeave			=	1;
 1537               		.loc 1 792 0
 1538 06ee 01E0      		ldi r16,lo8(1)
 1539 06f0 00C0      		rjmp .L180
 1540               	.LVL176:
 1541               	.L61:
 1542               	.LBB88:
 795:stk500boot.c  **** 				//*	fall thru
 796:stk500boot.c  **** 				break;
 797:stk500boot.c  **** 			case CMD_SET_PARAMETER: // same as enter progmode
 798:stk500boot.c  **** 			case CMD_ENTER_PROGMODE_ISP:
 799:stk500boot.c  **** 				msgLength		=	2;
 800:stk500boot.c  **** 				msgBuffer[1]	=	STATUS_CMD_OK;
 801:stk500boot.c  **** 				break;
 802:stk500boot.c  **** 
 803:stk500boot.c  **** 			case CMD_READ_SIGNATURE_ISP:
 804:stk500boot.c  **** 			{
 805:stk500boot.c  **** 				unsigned char signatureIndex	=	msgBuffer[4];
 1543               		.loc 1 805 0
 1544 06f2 8D81      		ldd r24,Y+5
 1545               	.LVL177:
 806:stk500boot.c  **** 				unsigned char signature;
 807:stk500boot.c  **** 
 808:stk500boot.c  **** 				if ( signatureIndex == 0 )
 1546               		.loc 1 808 0
 1547 06f4 8823      		tst r24
 1548 06f6 01F0      		breq .L122
 809:stk500boot.c  **** 					signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 810:stk500boot.c  **** 				else if ( signatureIndex == 1 )
 1549               		.loc 1 810 0
 1550 06f8 8130      		cpi r24,lo8(1)
 1551 06fa 01F4      		brne .L123
 811:stk500boot.c  **** 					signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 1552               		.loc 1 811 0
 1553 06fc 88E9      		ldi r24,lo8(-104)
 1554               	.LVL178:
 1555 06fe 00C0      		rjmp .L82
 1556               	.LVL179:
 1557               	.L122:
 809:stk500boot.c  **** 					signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 1558               		.loc 1 809 0
 1559 0700 8EE1      		ldi r24,lo8(30)
 1560               	.LVL180:
 1561 0702 00C0      		rjmp .L82
 1562               	.LVL181:
 1563               	.L123:
 812:stk500boot.c  **** 				else
 813:stk500boot.c  **** 					signature	=	SIGNATURE_BYTES & 0x000000FF;
 1564               		.loc 1 813 0
 1565 0704 81E0      		ldi r24,lo8(1)
 1566               	.LVL182:
 1567               	.L82:
 814:stk500boot.c  **** 
 815:stk500boot.c  **** 				msgLength		=	4;
 816:stk500boot.c  **** 				msgBuffer[1]	=	STATUS_CMD_OK;
 1568               		.loc 1 816 0
 1569 0706 1A82      		std Y+2,__zero_reg__
 817:stk500boot.c  **** 				msgBuffer[2]	=	signature;
 1570               		.loc 1 817 0
 1571 0708 8B83      		std Y+3,r24
 1572 070a 00C0      		rjmp .L182
 1573               	.LVL183:
 1574               	.L60:
 1575               	.LBE88:
 818:stk500boot.c  **** 				msgBuffer[3]	=	STATUS_CMD_OK;
 819:stk500boot.c  **** 
 820:stk500boot.c  **** 
 821:stk500boot.c  **** 			}
 822:stk500boot.c  **** 			break;
 823:stk500boot.c  **** 
 824:stk500boot.c  **** 			case CMD_READ_LOCK_ISP:
 825:stk500boot.c  **** 				msgLength		=	4;
 826:stk500boot.c  **** 				msgBuffer[1]	=	STATUS_CMD_OK;
 1576               		.loc 1 826 0
 1577 070c 1A82      		std Y+2,__zero_reg__
 1578               	.LBB89:
 827:stk500boot.c  **** 				msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 1579               		.loc 1 827 0
 1580 070e E1E0      		ldi r30,lo8(1)
 1581 0710 F0E0      		ldi r31,0
 1582 0712 89E0      		ldi r24,lo8(9)
 1583               	/* #APP */
 1584               	 ;  827 "stk500boot.c" 1
 1585 0714 8093 5700 		sts 87, r24
 1586 0718 E491      		lpm r30, Z
 1587               		
 1588               	 ;  0 "" 2
 1589               	/* #NOAPP */
 1590               	.L183:
 1591               	.LVL184:
 1592               	.LBE89:
 1593 071a EB83      		std Y+3,r30
 1594               	.LVL185:
 1595               	.L182:
 828:stk500boot.c  **** 				msgBuffer[3]	=	STATUS_CMD_OK;
 1596               		.loc 1 828 0
 1597 071c 1C82      		std Y+4,__zero_reg__
 829:stk500boot.c  **** 				break;
 1598               		.loc 1 829 0
 1599 071e 00E0      		ldi r16,0
 825:stk500boot.c  **** 				msgLength		=	4;
 1600               		.loc 1 825 0
 1601 0720 64E0      		ldi r22,lo8(4)
 1602 0722 70E0      		ldi r23,0
 1603               		.loc 1 829 0
 1604 0724 00C0      		rjmp .L80
 1605               	.LVL186:
 1606               	.L58:
 1607               	.LBB90:
 830:stk500boot.c  **** 
 831:stk500boot.c  **** 			case CMD_READ_FUSE_ISP:
 832:stk500boot.c  **** 			{
 833:stk500boot.c  **** 				unsigned char fuseBits;
 834:stk500boot.c  **** 
 835:stk500boot.c  **** 				if ( msgBuffer[2] == 0x50 )
 1608               		.loc 1 835 0
 1609 0726 8B81      		ldd r24,Y+3
 1610 0728 8035      		cpi r24,lo8(80)
 1611 072a 01F4      		brne .L83
 836:stk500boot.c  **** 				{
 837:stk500boot.c  **** 					if ( msgBuffer[3] == 0x08 )
 1612               		.loc 1 837 0
 1613 072c 8C81      		ldd r24,Y+4
 1614 072e 8830      		cpi r24,lo8(8)
 1615 0730 01F4      		brne .L84
 1616               	.LBB91:
 838:stk500boot.c  **** 						fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 1617               		.loc 1 838 0
 1618 0732 E2E0      		ldi r30,lo8(2)
 1619 0734 F0E0      		ldi r31,0
 1620 0736 00C0      		rjmp .L178
 1621               	.L84:
 1622               	.LBE91:
 1623               	.LBB92:
 839:stk500boot.c  **** 					else
 840:stk500boot.c  **** 						fuseBits	=	boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
 1624               		.loc 1 840 0
 1625 0738 E0E0      		ldi r30,0
 1626 073a F0E0      		ldi r31,0
 1627 073c 00C0      		rjmp .L178
 1628               	.L83:
 1629               	.LBE92:
 1630               	.LBB93:
 841:stk500boot.c  **** 				}
 842:stk500boot.c  **** 				else
 843:stk500boot.c  **** 				{
 844:stk500boot.c  **** 					fuseBits	=	boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
 1631               		.loc 1 844 0
 1632 073e E3E0      		ldi r30,lo8(3)
 1633 0740 F0E0      		ldi r31,0
 1634               	.L178:
 1635 0742 89E0      		ldi r24,lo8(9)
 1636               	/* #APP */
 1637               	 ;  844 "stk500boot.c" 1
 1638 0744 8093 5700 		sts 87, r24
 1639 0748 E491      		lpm r30, Z
 1640               		
 1641               	 ;  0 "" 2
 1642               	.LVL187:
 1643               	/* #NOAPP */
 1644               	.LBE93:
 845:stk500boot.c  **** 				}
 846:stk500boot.c  **** 				msgLength		=	4;
 847:stk500boot.c  **** 				msgBuffer[1]	=	STATUS_CMD_OK;
 1645               		.loc 1 847 0
 1646 074a 1A82      		std Y+2,__zero_reg__
 1647 074c 00C0      		rjmp .L183
 1648               	.LVL188:
 1649               	.L59:
 1650               	.LBE90:
 1651               	.LBB95:
 848:stk500boot.c  **** 				msgBuffer[2]	=	fuseBits;
 849:stk500boot.c  **** 				msgBuffer[3]	=	STATUS_CMD_OK;
 850:stk500boot.c  **** 			}
 851:stk500boot.c  **** 			break;
 852:stk500boot.c  **** 
 853:stk500boot.c  **** #ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
 854:stk500boot.c  **** 			case CMD_PROGRAM_LOCK_ISP:
 855:stk500boot.c  **** 			{
 856:stk500boot.c  **** 				unsigned char lockBits	=	msgBuffer[4];
 857:stk500boot.c  **** 
 858:stk500boot.c  **** 				lockBits	=	(~lockBits) & 0x3C;	// mask BLBxx bits
 1652               		.loc 1 858 0
 1653 074e 8D81      		ldd r24,Y+5
 1654               	.LVL189:
 1655               	.LBB96:
 859:stk500boot.c  **** 				boot_lock_bits_set(lockBits);		// and program it
 1656               		.loc 1 859 0
 1657 0750 836C      		ori r24,lo8(-61)
 1658               	.LVL190:
 1659 0752 99E0      		ldi r25,lo8(9)
 1660               	.LVL191:
 1661               	/* #APP */
 1662               	 ;  859 "stk500boot.c" 1
 1663 0754 E1E0      		ldi r30, 1
 1664 0756 F0E0      		ldi r31, 0
 1665 0758 082E      		mov r0, r24
 1666 075a 9093 5700 		sts 87, r25
 1667 075e E895      		spm
 1668               		
 1669               	 ;  0 "" 2
 1670               	/* #NOAPP */
 1671               	.L86:
 1672               	.LBE96:
 860:stk500boot.c  **** 				boot_spm_busy_wait();
 1673               		.loc 1 860 0 discriminator 1
 1674 0760 07B6      		in __tmp_reg__,0x37
 1675 0762 00FC      		sbrc __tmp_reg__,0
 1676 0764 00C0      		rjmp .L86
 1677               	.LVL192:
 861:stk500boot.c  **** 
 862:stk500boot.c  **** 				msgLength		=	3;
 863:stk500boot.c  **** 				msgBuffer[1]	=	STATUS_CMD_OK;
 1678               		.loc 1 863 0
 1679 0766 1A82      		std Y+2,__zero_reg__
 864:stk500boot.c  **** 				msgBuffer[2]	=	STATUS_CMD_OK;
 1680               		.loc 1 864 0
 1681 0768 1B82      		std Y+3,__zero_reg__
 1682               	.LVL193:
 1683               	.L179:
 1684               	.LBE95:
 865:stk500boot.c  **** 			}
 866:stk500boot.c  **** 			break;
 1685               		.loc 1 866 0
 1686 076a 00E0      		ldi r16,0
 862:stk500boot.c  **** 				msgLength		=	3;
 1687               		.loc 1 862 0
 1688 076c 63E0      		ldi r22,lo8(3)
 1689 076e 70E0      		ldi r23,0
 1690               		.loc 1 866 0
 1691 0770 00C0      		rjmp .L80
 1692               	.LVL194:
 1693               	.L55:
 867:stk500boot.c  **** #endif
 868:stk500boot.c  **** 			case CMD_CHIP_ERASE_ISP:
 869:stk500boot.c  **** 				eraseAddress	=	0;
 870:stk500boot.c  **** 				msgLength		=	2;
 871:stk500boot.c  **** 				msgBuffer[1]	=	STATUS_CMD_OK;
 1694               		.loc 1 871 0
 1695 0772 1A82      		std Y+2,__zero_reg__
 872:stk500boot.c  **** 				break;
 1696               		.loc 1 872 0
 1697 0774 00E0      		ldi r16,0
 870:stk500boot.c  **** 				msgLength		=	2;
 1698               		.loc 1 870 0
 1699 0776 62E0      		ldi r22,lo8(2)
 1700 0778 70E0      		ldi r23,0
 869:stk500boot.c  **** 				eraseAddress	=	0;
 1701               		.loc 1 869 0
 1702 077a 812C      		mov r8,__zero_reg__
 1703 077c 912C      		mov r9,__zero_reg__
 1704 077e 5401      		movw r10,r8
 1705               		.loc 1 872 0
 1706 0780 00C0      		rjmp .L80
 1707               	.LVL195:
 1708               	.L53:
 873:stk500boot.c  **** 
 874:stk500boot.c  **** 			case CMD_LOAD_ADDRESS:
 875:stk500boot.c  **** #if defined(RAMPZ)
 876:stk500boot.c  **** 				address	=	( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBuf
 1709               		.loc 1 876 0
 1710 0782 8A81      		ldd r24,Y+2
 1711 0784 2B81      		ldd r18,Y+3
 1712 0786 422F      		mov r20,r18
 1713 0788 50E0      		ldi r21,0
 1714 078a 60E0      		ldi r22,0
 1715 078c 70E0      		ldi r23,0
 1716 078e 3327      		clr r19
 1717 0790 2227      		clr r18
 1718 0792 582B      		or r21,r24
 1719 0794 8D81      		ldd r24,Y+5
 1720 0796 282B      		or r18,r24
 1721 0798 8C81      		ldd r24,Y+4
 1722 079a 382B      		or r19,r24
 1723 079c 220F      		lsl r18
 1724 079e 331F      		rol r19
 1725 07a0 441F      		rol r20
 1726 07a2 551F      		rol r21
 1727               	.L184:
 1728               	.LVL196:
 877:stk500boot.c  **** #else
 878:stk500boot.c  **** 				address	=	( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;		//convert word to byte address
 879:stk500boot.c  **** #endif
 880:stk500boot.c  **** 				msgLength		=	2;
 881:stk500boot.c  **** 				msgBuffer[1]	=	STATUS_CMD_OK;
 1729               		.loc 1 881 0
 1730 07a4 1A82      		std Y+2,__zero_reg__
 1731 07a6 00C0      		rjmp .L181
 1732               	.LVL197:
 1733               	.L56:
 1734               	.LBB97:
 882:stk500boot.c  **** 				break;
 883:stk500boot.c  **** 
 884:stk500boot.c  **** 			case CMD_PROGRAM_FLASH_ISP:
 885:stk500boot.c  **** 			case CMD_PROGRAM_EEPROM_ISP:
 886:stk500boot.c  **** 			{
 887:stk500boot.c  **** 				unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2]; // 80
 1735               		.loc 1 887 0
 1736 07a8 FA81      		ldd r31,Y+2
 1737 07aa C15E      		subi r28,lo8(-287)
 1738 07ac DE4F      		sbci r29,hi8(-287)
 1739 07ae F883      		st Y,r31
 1740 07b0 CF51      		subi r28,lo8(287)
 1741 07b2 D140      		sbci r29,hi8(287)
 1742 07b4 C25E      		subi r28,lo8(-286)
 1743 07b6 DE4F      		sbci r29,hi8(-286)
 1744 07b8 1882      		st Y,__zero_reg__
 1745 07ba CE51      		subi r28,lo8(286)
 1746 07bc D140      		sbci r29,hi8(286)
 1747 07be 8B81      		ldd r24,Y+3
 1748 07c0 C25E      		subi r28,lo8(-286)
 1749 07c2 DE4F      		sbci r29,hi8(-286)
 1750 07c4 6881      		ld r22,Y
 1751 07c6 7981      		ldd r23,Y+1
 1752 07c8 CE51      		subi r28,lo8(286)
 1753 07ca D140      		sbci r29,hi8(286)
 1754 07cc 682B      		or r22,r24
 1755 07ce CB01      		movw r24,r22
 1756               	.LVL198:
 888:stk500boot.c  **** 				unsigned char	*p	=	msgBuffer+10;
 889:stk500boot.c  **** 				unsigned int	data;
 890:stk500boot.c  **** 				unsigned char	highByte, lowByte;
 891:stk500boot.c  **** 				address_t		tempaddress	=	address;
 892:stk500boot.c  **** 
 893:stk500boot.c  **** 
 894:stk500boot.c  **** 				if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
 1757               		.loc 1 894 0
 1758 07d0 E331      		cpi r30,lo8(19)
 1759 07d2 01F0      		breq .+2
 1760 07d4 00C0      		rjmp .L124
 895:stk500boot.c  **** 				{
 896:stk500boot.c  **** 					// erase only main section (bootloader protection)
 897:stk500boot.c  **** 					if (eraseAddress < APP_END )
 1761               		.loc 1 897 0
 1762 07d6 8114      		cp r8,__zero_reg__
 1763 07d8 70EC      		ldi r23,-64
 1764 07da 9706      		cpc r9,r23
 1765 07dc 73E0      		ldi r23,3
 1766 07de A706      		cpc r10,r23
 1767 07e0 B104      		cpc r11,__zero_reg__
 1768 07e2 00F4      		brsh .L88
 898:stk500boot.c  **** 					{
 899:stk500boot.c  **** 						boot_page_erase(eraseAddress);	// Perform page erase
 1769               		.loc 1 899 0
 1770 07e4 63E0      		ldi r22,lo8(3)
 1771               	.LVL199:
 1772               	/* #APP */
 1773               	 ;  899 "stk500boot.c" 1
 1774 07e6 F401      		movw r30, r8
 1775 07e8 A092 5B00 		sts  91, r10
 1776 07ec 6093 5700 		sts 87, r22
 1777 07f0 E895      		spm
 1778               		
 1779               	 ;  0 "" 2
 1780               	/* #NOAPP */
 1781               	.L89:
 900:stk500boot.c  **** 						boot_spm_busy_wait();		// Wait until the memory is erased.
 1782               		.loc 1 900 0 discriminator 1
 1783 07f2 07B6      		in __tmp_reg__,0x37
 1784 07f4 00FC      		sbrc __tmp_reg__,0
 1785 07f6 00C0      		rjmp .L89
 901:stk500boot.c  **** 						eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
 1786               		.loc 1 901 0
 1787 07f8 AFEF      		ldi r26,-1
 1788 07fa 9A1A      		sub r9,r26
 1789 07fc AA0A      		sbc r10,r26
 1790 07fe BA0A      		sbc r11,r26
 1791               	.LVL200:
 1792               	.L88:
 1793 0800 6B85      		ldd r22,Y+11
 1794 0802 DE01      		movw r26,r28
 1795 0804 1D96      		adiw r26,13
 1796               	.LBE97:
 1797               	.LBB98:
 1798               	.LBB94:
 838:stk500boot.c  **** 						fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 1799               		.loc 1 838 0 discriminator 1
 1800 0806 6901      		movw r12,r18
 1801 0808 7A01      		movw r14,r20
 1802               	.LBE94:
 1803               	.LBE98:
 1804               	.LBB99:
 902:stk500boot.c  **** 					}
 903:stk500boot.c  **** 
 904:stk500boot.c  **** 					/* Write FLASH */
 905:stk500boot.c  **** 					do {
 906:stk500boot.c  **** 						lowByte		=	*p++;
 907:stk500boot.c  **** 						highByte 	=	*p++;
 908:stk500boot.c  **** 
 909:stk500boot.c  **** 						data		=	(highByte << 8) | lowByte;
 910:stk500boot.c  **** 						boot_page_fill(address,data);
 1805               		.loc 1 910 0 discriminator 1
 1806 080a 01E0      		ldi r16,lo8(1)
 1807               	.L91:
 1808               	.LVL201:
 467:stk500boot.c  **** int main(void)
 1809               		.loc 1 467 0 discriminator 1
 1810 080c FD01      		movw r30,r26
 1811 080e 3197      		sbiw r30,1
 1812               	.LVL202:
 909:stk500boot.c  **** 						data		=	(highByte << 8) | lowByte;
 1813               		.loc 1 909 0 discriminator 1
 1814 0810 7081      		ld r23,Z
 1815 0812 CF5D      		subi r28,lo8(-289)
 1816 0814 DE4F      		sbci r29,hi8(-289)
 1817 0816 7883      		st Y,r23
 1818 0818 C152      		subi r28,lo8(289)
 1819 081a D140      		sbci r29,hi8(289)
 1820 081c C05E      		subi r28,lo8(-288)
 1821 081e DE4F      		sbci r29,hi8(-288)
 1822 0820 1882      		st Y,__zero_reg__
 1823 0822 C052      		subi r28,lo8(288)
 1824 0824 D140      		sbci r29,hi8(288)
 1825 0826 C05E      		subi r28,lo8(-288)
 1826 0828 DE4F      		sbci r29,hi8(-288)
 1827 082a E881      		ld r30,Y
 1828 082c F981      		ldd r31,Y+1
 1829 082e C052      		subi r28,lo8(288)
 1830 0830 D140      		sbci r29,hi8(288)
 1831               	.LVL203:
 1832 0832 E62B      		or r30,r22
 1833 0834 BF01      		movw r22,r30
 1834               	.LVL204:
 1835               		.loc 1 910 0 discriminator 1
 1836               	/* #APP */
 1837               	 ;  910 "stk500boot.c" 1
 1838 0836 0B01      		movw  r0, r22
 1839 0838 F601      		movw r30, r12
 1840 083a E092 5B00 		sts 91, r14
 1841 083e 0093 5700 		sts 87, r16
 1842 0842 E895      		spm
 1843 0844 1124      		clr  r1
 1844               		
 1845               	 ;  0 "" 2
 911:stk500boot.c  **** 
 912:stk500boot.c  **** 						address	=	address + 2;	// Select next word in memory
 1846               		.loc 1 912 0 discriminator 1
 1847               	/* #NOAPP */
 1848 0846 F2E0      		ldi r31,2
 1849 0848 CF0E      		add r12,r31
 1850 084a D11C      		adc r13,__zero_reg__
 1851 084c E11C      		adc r14,__zero_reg__
 1852 084e F11C      		adc r15,__zero_reg__
 1853               	.LVL205:
 913:stk500boot.c  **** 						size	-=	2;				// Reduce number of bytes to write by two
 1854               		.loc 1 913 0 discriminator 1
 1855 0850 0297      		sbiw r24,2
 1856               	.LVL206:
 914:stk500boot.c  **** 					} while (size);					// Loop until all bytes written
 1857               		.loc 1 914 0 discriminator 1
 1858 0852 01F0      		breq .L90
 907:stk500boot.c  **** 						highByte 	=	*p++;
 1859               		.loc 1 907 0
 1860 0854 6C91      		ld r22,X
 1861 0856 1296      		adiw r26,2
 1862 0858 00C0      		rjmp .L91
 1863               	.L90:
 915:stk500boot.c  **** 
 916:stk500boot.c  **** 					boot_page_write(tempaddress);
 1864               		.loc 1 916 0
 1865 085a 85E0      		ldi r24,lo8(5)
 1866               	.LVL207:
 1867               	/* #APP */
 1868               	 ;  916 "stk500boot.c" 1
 1869 085c F901      		movw r30, r18
 1870 085e 4093 5B00 		sts 91, r20
 1871 0862 8093 5700 		sts 87, r24
 1872 0866 E895      		spm
 1873               		
 1874               	 ;  0 "" 2
 917:stk500boot.c  **** 
 918:stk500boot.c  **** 					//show progress
 919:stk500boot.c  **** 					send_command(0x15);
 1875               		.loc 1 919 0
 1876               	/* #NOAPP */
 1877 0868 85E1      		ldi r24,lo8(21)
 1878 086a C85D      		subi r28,lo8(-296)
 1879 086c DE4F      		sbci r29,hi8(-296)
 1880 086e 2883      		st Y,r18
 1881 0870 C852      		subi r28,lo8(296)
 1882 0872 D140      		sbci r29,hi8(296)
 1883 0874 C75D      		subi r28,lo8(-297)
 1884 0876 DE4F      		sbci r29,hi8(-297)
 1885 0878 3883      		st Y,r19
 1886 087a C952      		subi r28,lo8(297)
 1887 087c D140      		sbci r29,hi8(297)
 1888 087e C65D      		subi r28,lo8(-298)
 1889 0880 DE4F      		sbci r29,hi8(-298)
 1890 0882 4883      		st Y,r20
 1891 0884 CA52      		subi r28,lo8(298)
 1892 0886 D140      		sbci r29,hi8(298)
 1893 0888 C55D      		subi r28,lo8(-299)
 1894 088a DE4F      		sbci r29,hi8(-299)
 1895 088c 5883      		st Y,r21
 1896 088e CB52      		subi r28,lo8(299)
 1897 0890 D140      		sbci r29,hi8(299)
 1898 0892 0E94 0000 		call send_command
 1899               	.LVL208:
 920:stk500boot.c  **** 					send_command(124*tempaddress/APP_END/2+1);
 1900               		.loc 1 920 0
 1901 0896 ACE7      		ldi r26,lo8(124)
 1902 0898 B0E0      		ldi r27,0
 1903 089a C85D      		subi r28,lo8(-296)
 1904 089c DE4F      		sbci r29,hi8(-296)
 1905 089e 2881      		ld r18,Y
 1906 08a0 C852      		subi r28,lo8(296)
 1907 08a2 D140      		sbci r29,hi8(296)
 1908 08a4 C75D      		subi r28,lo8(-297)
 1909 08a6 DE4F      		sbci r29,hi8(-297)
 1910 08a8 3881      		ld r19,Y
 1911 08aa C952      		subi r28,lo8(297)
 1912 08ac D140      		sbci r29,hi8(297)
 1913 08ae C65D      		subi r28,lo8(-298)
 1914 08b0 DE4F      		sbci r29,hi8(-298)
 1915 08b2 4881      		ld r20,Y
 1916 08b4 CA52      		subi r28,lo8(298)
 1917 08b6 D140      		sbci r29,hi8(298)
 1918 08b8 C55D      		subi r28,lo8(-299)
 1919 08ba DE4F      		sbci r29,hi8(-299)
 1920 08bc 5881      		ld r21,Y
 1921 08be CB52      		subi r28,lo8(299)
 1922 08c0 D140      		sbci r29,hi8(299)
 1923 08c2 0E94 0000 		call __muluhisi3
 1924 08c6 20E0      		ldi r18,0
 1925 08c8 30E8      		ldi r19,lo8(-128)
 1926 08ca 47E0      		ldi r20,lo8(7)
 1927 08cc 50E0      		ldi r21,0
 1928 08ce 0E94 0000 		call __udivmodsi4
 1929 08d2 022F      		mov r16,r18
 1930 08d4 0F5F      		subi r16,lo8(-(1))
 1931 08d6 802F      		mov r24,r16
 1932 08d8 0E94 0000 		call send_command
 1933               	.LVL209:
 921:stk500boot.c  **** 					send_command(124*tempaddress/APP_END/2+1);
 1934               		.loc 1 921 0
 1935 08dc 802F      		mov r24,r16
 1936 08de 0E94 0000 		call send_command
 1937               	.LVL210:
 922:stk500boot.c  **** 					send_command(0x75);
 1938               		.loc 1 922 0
 1939 08e2 85E7      		ldi r24,lo8(117)
 1940 08e4 0E94 0000 		call send_command
 1941               	.LVL211:
 923:stk500boot.c  **** 					send_command(LOADING_Y+2);
 1942               		.loc 1 923 0
 1943 08e8 89E3      		ldi r24,lo8(57)
 1944 08ea 0E94 0000 		call send_command
 1945               	.LVL212:
 924:stk500boot.c  **** 					send_command(LOADING_Y+2);
 1946               		.loc 1 924 0
 1947 08ee 89E3      		ldi r24,lo8(57)
 1948 08f0 0E94 0000 		call send_command
 1949               	.LVL213:
 925:stk500boot.c  **** 					send_char(0xff);
 1950               		.loc 1 925 0
 1951 08f4 8FEF      		ldi r24,lo8(-1)
 1952 08f6 0E94 0000 		call send_char
 1953               	.LVL214:
 1954               	.L92:
 926:stk500boot.c  **** 					//show progress
 927:stk500boot.c  **** 					boot_spm_busy_wait();
 1955               		.loc 1 927 0 discriminator 1
 1956 08fa 07B6      		in __tmp_reg__,0x37
 1957 08fc 00FC      		sbrc __tmp_reg__,0
 1958 08fe 00C0      		rjmp .L92
 928:stk500boot.c  **** 					boot_rww_enable();				// Re-enable the RWW section
 1959               		.loc 1 928 0
 1960 0900 81E1      		ldi r24,lo8(17)
 1961               	/* #APP */
 1962               	 ;  928 "stk500boot.c" 1
 1963 0902 8093 5700 		sts 87, r24
 1964 0906 E895      		spm
 1965               		
 1966               	 ;  0 "" 2
 1967               	/* #NOAPP */
 1968 0908 00C0      		rjmp .L93
 1969               	.LVL215:
 1970               	.L124:
 894:stk500boot.c  **** 				if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
 1971               		.loc 1 894 0
 1972 090a BC01      		movw r22,r24
 1973               	.LVL216:
 1974 090c 6901      		movw r12,r18
 1975 090e 7A01      		movw r14,r20
 888:stk500boot.c  **** 				unsigned char	*p	=	msgBuffer+10;
 1976               		.loc 1 888 0
 1977 0910 FE01      		movw r30,r28
 1978 0912 3B96      		adiw r30,11
 1979               	.LVL217:
 1980               	.L87:
 929:stk500boot.c  **** 				}
 930:stk500boot.c  **** 				else
 931:stk500boot.c  **** 				{
 932:stk500boot.c  **** 					/* write EEPROM */
 933:stk500boot.c  **** 					do {
 934:stk500boot.c  **** 						EEARL	=	address;			// Setup EEPROM address
 1981               		.loc 1 934 0
 1982 0914 C1BC      		out 0x21,r12
 935:stk500boot.c  **** 						EEARH	=	(address >> 8);
 1983               		.loc 1 935 0
 1984 0916 4D2C      		mov r4,r13
 1985 0918 5E2C      		mov r5,r14
 1986 091a 6F2C      		mov r6,r15
 1987 091c 7724      		clr r7
 1988 091e 42BC      		out 0x22,r4
 936:stk500boot.c  **** 						address++;						// Select next EEPROM byte
 1989               		.loc 1 936 0
 1990 0920 0FEF      		ldi r16,-1
 1991 0922 C01A      		sub r12,r16
 1992 0924 D00A      		sbc r13,r16
 1993 0926 E00A      		sbc r14,r16
 1994 0928 F00A      		sbc r15,r16
 1995               	.LVL218:
 937:stk500boot.c  **** 
 938:stk500boot.c  **** 						EEDR	=	*p++;				// get byte from buffer
 1996               		.loc 1 938 0
 1997 092a A191      		ld r26,Z+
 1998               	.LVL219:
 1999 092c A0BD      		out 0x20,r26
 2000               	.LVL220:
 939:stk500boot.c  **** 						EECR	|=	(1<<EEMWE);			// Write data into EEPROM
 2001               		.loc 1 939 0
 2002 092e FA9A      		sbi 0x1f,2
 940:stk500boot.c  **** 						EECR	|=	(1<<EEWE);
 2003               		.loc 1 940 0
 2004 0930 F99A      		sbi 0x1f,1
 2005               	.L94:
 941:stk500boot.c  **** 
 942:stk500boot.c  **** 						while (EECR & (1<<EEWE));	// Wait for write operation to finish
 2006               		.loc 1 942 0 discriminator 1
 2007 0932 F999      		sbic 0x1f,1
 2008 0934 00C0      		rjmp .L94
 943:stk500boot.c  **** 						size--;						// Decrease number of bytes to write
 2009               		.loc 1 943 0
 2010 0936 6150      		subi r22,1
 2011 0938 7109      		sbc r23,__zero_reg__
 2012               	.LVL221:
 944:stk500boot.c  **** 					} while (size);					// Loop until all bytes written
 2013               		.loc 1 944 0
 2014 093a 01F4      		brne .L87
 467:stk500boot.c  **** int main(void)
 2015               		.loc 1 467 0
 2016 093c 6C01      		movw r12,r24
 2017               	.LVL222:
 2018 093e 61E0      		ldi r22,1
 2019 0940 C61A      		sub r12,r22
 2020 0942 D108      		sbc r13,__zero_reg__
 2021               	.LVL223:
 2022 0944 E12C      		mov r14,__zero_reg__
 2023 0946 F12C      		mov r15,__zero_reg__
 2024 0948 7FEF      		ldi r23,-1
 2025 094a C71A      		sub r12,r23
 2026 094c D70A      		sbc r13,r23
 2027 094e E70A      		sbc r14,r23
 2028 0950 F70A      		sbc r15,r23
 2029 0952 C20E      		add r12,r18
 2030 0954 D31E      		adc r13,r19
 2031 0956 E41E      		adc r14,r20
 2032 0958 F51E      		adc r15,r21
 2033               	.LVL224:
 2034               	.L93:
 945:stk500boot.c  **** 				}
 946:stk500boot.c  **** 				msgLength	=	2;
 947:stk500boot.c  **** 				msgBuffer[1]	=	STATUS_CMD_OK;
 2035               		.loc 1 947 0
 2036 095a 1A82      		std Y+2,__zero_reg__
 2037               	.LBE99:
 948:stk500boot.c  **** 			}
 949:stk500boot.c  **** 			break;
 2038               		.loc 1 949 0
 2039 095c A701      		movw r20,r14
 2040 095e 9601      		movw r18,r12
 2041 0960 00C0      		rjmp .L181
 2042               	.LVL225:
 2043               	.L57:
 2044               	.LBB100:
 950:stk500boot.c  **** 
 951:stk500boot.c  **** 			case CMD_READ_FLASH_ISP:
 952:stk500boot.c  **** 			case CMD_READ_EEPROM_ISP:
 953:stk500boot.c  **** 			{
 954:stk500boot.c  **** 				unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
 2045               		.loc 1 954 0
 2046 0962 8A81      		ldd r24,Y+2
 2047 0964 CD5D      		subi r28,lo8(-291)
 2048 0966 DE4F      		sbci r29,hi8(-291)
 2049 0968 8883      		st Y,r24
 2050 096a C352      		subi r28,lo8(291)
 2051 096c D140      		sbci r29,hi8(291)
 2052 096e CE5D      		subi r28,lo8(-290)
 2053 0970 DE4F      		sbci r29,hi8(-290)
 2054 0972 1882      		st Y,__zero_reg__
 2055 0974 C252      		subi r28,lo8(290)
 2056 0976 D140      		sbci r29,hi8(290)
 2057 0978 8B81      		ldd r24,Y+3
 2058 097a CE5D      		subi r28,lo8(-290)
 2059 097c DE4F      		sbci r29,hi8(-290)
 2060 097e 6881      		ld r22,Y
 2061 0980 7981      		ldd r23,Y+1
 2062 0982 C252      		subi r28,lo8(290)
 2063 0984 D140      		sbci r29,hi8(290)
 2064 0986 682B      		or r22,r24
 2065 0988 CB01      		movw r24,r22
 2066               	.LVL226:
 955:stk500boot.c  **** 				unsigned char	*p		=	msgBuffer+1;
 956:stk500boot.c  **** 				msgLength				=	size+3;
 2067               		.loc 1 956 0
 2068 098a 6D5F      		subi r22,-3
 2069 098c 7F4F      		sbci r23,-1
 2070               	.LVL227:
 957:stk500boot.c  **** 
 958:stk500boot.c  **** 				*p++	=	STATUS_CMD_OK;
 2071               		.loc 1 958 0
 2072 098e 1A82      		std Y+2,__zero_reg__
 2073               	.LVL228:
 959:stk500boot.c  **** 				if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 2074               		.loc 1 959 0
 2075 0990 E431      		cpi r30,lo8(20)
 2076 0992 01F4      		brne .L125
 2077 0994 7E01      		movw r14,r28
 2078 0996 A4E0      		ldi r26,4
 2079 0998 EA0E      		add r14,r26
 2080 099a F11C      		adc r15,__zero_reg__
 958:stk500boot.c  **** 				*p++	=	STATUS_CMD_OK;
 2081               		.loc 1 958 0
 2082 099c DE01      		movw r26,r28
 2083 099e 1396      		adiw r26,3
 2084               	.L96:
 2085               	.LVL229:
 2086               	.LBB101:
 2087               	.LBB102:
 960:stk500boot.c  **** 				{
 961:stk500boot.c  **** 					unsigned int data;
 962:stk500boot.c  **** 
 963:stk500boot.c  **** 					// Read FLASH
 964:stk500boot.c  **** 					do {
 965:stk500boot.c  **** #if defined(RAMPZ)
 966:stk500boot.c  **** 						data	=	pgm_read_word_far(address);
 2088               		.loc 1 966 0 discriminator 1
 2089               	/* #APP */
 2090               	 ;  966 "stk500boot.c" 1
 2091 09a0 4BBF      		out 59, r20
 2092 09a2 F901      		movw r30, r18
 2093 09a4 C790      		elpm r12, Z+
 2094 09a6 D690      		elpm r13, Z
 2095               		
 2096               	 ;  0 "" 2
 2097               	/* #NOAPP */
 2098               	.LBE102:
 967:stk500boot.c  **** #else
 968:stk500boot.c  **** 						data	=	pgm_read_word_near(address);
 969:stk500boot.c  **** #endif
 970:stk500boot.c  **** 						*p++	=	(unsigned char)data;		//LSB
 2099               		.loc 1 970 0 discriminator 1
 2100 09a8 CC92      		st X,r12
 2101               	.LVL230:
 971:stk500boot.c  **** 						*p++	=	(unsigned char)(data >> 8);	//MSB
 2102               		.loc 1 971 0 discriminator 1
 2103 09aa F701      		movw r30,r14
 2104 09ac D082      		st Z,r13
 467:stk500boot.c  **** int main(void)
 2105               		.loc 1 467 0 discriminator 1
 2106 09ae 1296      		adiw r26,2
 2107               	.LVL231:
 972:stk500boot.c  **** 						address	+=	2;							// Select next word in memory
 2108               		.loc 1 972 0 discriminator 1
 2109 09b0 2E5F      		subi r18,-2
 2110 09b2 3F4F      		sbci r19,-1
 2111 09b4 4F4F      		sbci r20,-1
 2112 09b6 5F4F      		sbci r21,-1
 2113               	.LVL232:
 973:stk500boot.c  **** 						size	-=	2;
 2114               		.loc 1 973 0 discriminator 1
 2115 09b8 0297      		sbiw r24,2
 2116               	.LVL233:
 2117 09ba F2E0      		ldi r31,2
 2118 09bc EF0E      		add r14,r31
 2119 09be F11C      		adc r15,__zero_reg__
 974:stk500boot.c  **** 					}while (size);
 2120               		.loc 1 974 0 discriminator 1
 2121 09c0 0097      		sbiw r24,0
 2122 09c2 01F4      		brne .L96
 2123 09c4 00C0      		rjmp .L97
 2124               	.LVL234:
 2125               	.L125:
 2126               	.LBE101:
 959:stk500boot.c  **** 				if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 2127               		.loc 1 959 0
 2128 09c6 FC01      		movw r30,r24
 2129 09c8 6901      		movw r12,r18
 2130 09ca 7A01      		movw r14,r20
 958:stk500boot.c  **** 				*p++	=	STATUS_CMD_OK;
 2131               		.loc 1 958 0
 2132 09cc DE01      		movw r26,r28
 2133 09ce 1396      		adiw r26,3
 2134               	.LVL235:
 2135               	.L95:
 975:stk500boot.c  **** 				}
 976:stk500boot.c  **** 				else
 977:stk500boot.c  **** 				{
 978:stk500boot.c  **** 					/* Read EEPROM */
 979:stk500boot.c  **** 					do {
 980:stk500boot.c  **** 						EEARL	=	address;			// Setup EEPROM address
 2136               		.loc 1 980 0 discriminator 1
 2137 09d0 C1BC      		out 0x21,r12
 981:stk500boot.c  **** 						EEARH	=	((address >> 8));
 2138               		.loc 1 981 0 discriminator 1
 2139 09d2 4D2C      		mov r4,r13
 2140 09d4 5E2C      		mov r5,r14
 2141 09d6 6F2C      		mov r6,r15
 2142 09d8 7724      		clr r7
 2143 09da 42BC      		out 0x22,r4
 982:stk500boot.c  **** 						address++;					// Select next EEPROM byte
 2144               		.loc 1 982 0 discriminator 1
 2145 09dc 0FEF      		ldi r16,-1
 2146 09de C01A      		sub r12,r16
 2147 09e0 D00A      		sbc r13,r16
 2148 09e2 E00A      		sbc r14,r16
 2149 09e4 F00A      		sbc r15,r16
 2150               	.LVL236:
 983:stk500boot.c  **** 						EECR	|=	(1<<EERE);			// Read EEPROM
 2151               		.loc 1 983 0 discriminator 1
 2152 09e6 F89A      		sbi 0x1f,0
 984:stk500boot.c  **** 						*p++	=	EEDR;				// Send EEPROM data
 2153               		.loc 1 984 0 discriminator 1
 2154 09e8 00B5      		in r16,0x20
 2155 09ea 0D93      		st X+,r16
 2156               	.LVL237:
 985:stk500boot.c  **** 						size--;
 2157               		.loc 1 985 0 discriminator 1
 2158 09ec 3197      		sbiw r30,1
 2159               	.LVL238:
 986:stk500boot.c  **** 					} while (size);
 2160               		.loc 1 986 0 discriminator 1
 2161 09ee 01F4      		brne .L95
 467:stk500boot.c  **** int main(void)
 2162               		.loc 1 467 0
 2163 09f0 6C01      		movw r12,r24
 2164               	.LVL239:
 2165 09f2 A1E0      		ldi r26,1
 2166 09f4 CA1A      		sub r12,r26
 2167 09f6 D108      		sbc r13,__zero_reg__
 2168               	.LVL240:
 2169 09f8 E12C      		mov r14,__zero_reg__
 2170 09fa F12C      		mov r15,__zero_reg__
 2171 09fc EFEF      		ldi r30,-1
 2172 09fe CE1A      		sub r12,r30
 2173 0a00 DE0A      		sbc r13,r30
 2174 0a02 EE0A      		sbc r14,r30
 2175 0a04 FE0A      		sbc r15,r30
 2176               	.LVL241:
 2177 0a06 2C0D      		add r18,r12
 2178 0a08 3D1D      		adc r19,r13
 2179 0a0a 4E1D      		adc r20,r14
 2180 0a0c 5F1D      		adc r21,r15
 2181 0a0e A3E0      		ldi r26,lo8(3)
 2182 0a10 B0E0      		ldi r27,0
 2183 0a12 AC0F      		add r26,r28
 2184 0a14 BD1F      		adc r27,r29
 2185 0a16 A80F      		add r26,r24
 2186 0a18 B91F      		adc r27,r25
 2187               	.L97:
 2188               	.LVL242:
 987:stk500boot.c  **** 				}
 988:stk500boot.c  **** 				*p++	=	STATUS_CMD_OK;
 2189               		.loc 1 988 0
 2190 0a1a 1C92      		st X,__zero_reg__
 2191               	.LVL243:
 2192               	.LBE100:
 989:stk500boot.c  **** 			}
 990:stk500boot.c  **** 			break;
 2193               		.loc 1 990 0
 2194 0a1c 00E0      		ldi r16,0
 2195 0a1e 00C0      		rjmp .L80
 2196               	.LVL244:
 2197               	.L49:
 991:stk500boot.c  **** 
 992:stk500boot.c  **** 			default:
 993:stk500boot.c  **** 				msgLength		=	2;
 994:stk500boot.c  **** 				msgBuffer[1]	=	STATUS_CMD_FAILED;
 2198               		.loc 1 994 0
 2199 0a20 80EC      		ldi r24,lo8(-64)
 2200 0a22 8A83      		std Y+2,r24
 2201               	.LVL245:
 2202               	.L181:
 995:stk500boot.c  **** 				break;
 2203               		.loc 1 995 0
 2204 0a24 00E0      		ldi r16,0
 2205               	.L180:
 993:stk500boot.c  **** 				msgLength		=	2;
 2206               		.loc 1 993 0
 2207 0a26 62E0      		ldi r22,lo8(2)
 2208 0a28 70E0      		ldi r23,0
 2209               	.LVL246:
 2210               	.L80:
 996:stk500boot.c  **** 			}
 997:stk500boot.c  **** 
 998:stk500boot.c  **** 			/*
 999:stk500boot.c  **** 			 * Now send answer message back
1000:stk500boot.c  **** 			 */
1001:stk500boot.c  **** 			sendchar(MESSAGE_START);
 2211               		.loc 1 1001 0
 2212 0a2a 8BE1      		ldi r24,lo8(27)
 2213 0a2c C85D      		subi r28,lo8(-296)
 2214 0a2e DE4F      		sbci r29,hi8(-296)
 2215 0a30 2883      		st Y,r18
 2216 0a32 C852      		subi r28,lo8(296)
 2217 0a34 D140      		sbci r29,hi8(296)
 2218 0a36 C75D      		subi r28,lo8(-297)
 2219 0a38 DE4F      		sbci r29,hi8(-297)
 2220 0a3a 3883      		st Y,r19
 2221 0a3c C952      		subi r28,lo8(297)
 2222 0a3e D140      		sbci r29,hi8(297)
 2223 0a40 C65D      		subi r28,lo8(-298)
 2224 0a42 DE4F      		sbci r29,hi8(-298)
 2225 0a44 4883      		st Y,r20
 2226 0a46 CA52      		subi r28,lo8(298)
 2227 0a48 D140      		sbci r29,hi8(298)
 2228 0a4a C55D      		subi r28,lo8(-299)
 2229 0a4c DE4F      		sbci r29,hi8(-299)
 2230 0a4e 5883      		st Y,r21
 2231 0a50 CB52      		subi r28,lo8(299)
 2232 0a52 D140      		sbci r29,hi8(299)
 2233 0a54 CA5D      		subi r28,lo8(-294)
 2234 0a56 DE4F      		sbci r29,hi8(-294)
 2235 0a58 6883      		st Y,r22
 2236 0a5a C652      		subi r28,lo8(294)
 2237 0a5c D140      		sbci r29,hi8(294)
 2238 0a5e C95D      		subi r28,lo8(-295)
 2239 0a60 DE4F      		sbci r29,hi8(-295)
 2240 0a62 7883      		st Y,r23
 2241 0a64 C752      		subi r28,lo8(295)
 2242 0a66 D140      		sbci r29,hi8(295)
 2243 0a68 0E94 0000 		call sendchar
 2244               	.LVL247:
1002:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
1003:stk500boot.c  **** 
1004:stk500boot.c  **** 			sendchar(seqNum);
 2245               		.loc 1 1004 0
 2246 0a6c 812F      		mov r24,r17
 2247 0a6e 0E94 0000 		call sendchar
 2248               	.LVL248:
1005:stk500boot.c  **** 			checksum	^=	seqNum;
1006:stk500boot.c  **** 
1007:stk500boot.c  **** 			c			=	((msgLength>>8)&0xFF);
 2249               		.loc 1 1007 0
 2250 0a72 C95D      		subi r28,lo8(-295)
 2251 0a74 DE4F      		sbci r29,hi8(-295)
 2252 0a76 7881      		ld r23,Y
 2253 0a78 C752      		subi r28,lo8(295)
 2254 0a7a D140      		sbci r29,hi8(295)
 2255 0a7c F72E      		mov r15,r23
 2256               	.LVL249:
1008:stk500boot.c  **** 			sendchar(c);
 2257               		.loc 1 1008 0
 2258 0a7e 872F      		mov r24,r23
 2259 0a80 0E94 0000 		call sendchar
 2260               	.LVL250:
1009:stk500boot.c  **** 			checksum	^=	c;
1010:stk500boot.c  **** 
1011:stk500boot.c  **** 			c			=	msgLength&0x00FF;
 2261               		.loc 1 1011 0
 2262 0a84 CA5D      		subi r28,lo8(-294)
 2263 0a86 DE4F      		sbci r29,hi8(-294)
 2264 0a88 6881      		ld r22,Y
 2265 0a8a C652      		subi r28,lo8(294)
 2266 0a8c D140      		sbci r29,hi8(294)
 2267 0a8e E62E      		mov r14,r22
 2268               	.LVL251:
1012:stk500boot.c  **** 			sendchar(c);
 2269               		.loc 1 1012 0
 2270 0a90 862F      		mov r24,r22
 2271 0a92 0E94 0000 		call sendchar
 2272               	.LVL252:
1013:stk500boot.c  **** 			checksum ^= c;
1014:stk500boot.c  **** 
1015:stk500boot.c  **** 			sendchar(TOKEN);
 2273               		.loc 1 1015 0
 2274 0a96 8EE0      		ldi r24,lo8(14)
 2275 0a98 0E94 0000 		call sendchar
 2276               	.LVL253:
1009:stk500boot.c  **** 			checksum	^=	c;
 2277               		.loc 1 1009 0
 2278 0a9c 95E1      		ldi r25,lo8(21)
 2279 0a9e 792E      		mov r7,r25
 2280 0aa0 7126      		eor r7,r17
1013:stk500boot.c  **** 			checksum ^= c;
 2281               		.loc 1 1013 0
 2282 0aa2 7E24      		eor r7,r14
1016:stk500boot.c  **** 			checksum ^= TOKEN;
 2283               		.loc 1 1016 0
 2284 0aa4 7F24      		eor r7,r15
 2285               	.LVL254:
 467:stk500boot.c  **** int main(void)
 2286               		.loc 1 467 0
 2287 0aa6 CA5D      		subi r28,lo8(-294)
 2288 0aa8 DE4F      		sbci r29,hi8(-294)
 2289 0aaa 6881      		ld r22,Y
 2290 0aac C652      		subi r28,lo8(294)
 2291 0aae D140      		sbci r29,hi8(294)
 2292 0ab0 C95D      		subi r28,lo8(-295)
 2293 0ab2 DE4F      		sbci r29,hi8(-295)
 2294 0ab4 7881      		ld r23,Y
 2295 0ab6 C752      		subi r28,lo8(295)
 2296 0ab8 D140      		sbci r29,hi8(295)
 2297 0aba CC24      		clr r12
 2298 0abc C394      		inc r12
 2299 0abe D12C      		mov r13,__zero_reg__
 2300 0ac0 CC0E      		add r12,r28
 2301 0ac2 DD1E      		adc r13,r29
 2302 0ac4 C60E      		add r12,r22
 2303 0ac6 D71E      		adc r13,r23
1017:stk500boot.c  **** 
1018:stk500boot.c  **** 			p	=	msgBuffer;
 2304               		.loc 1 1018 0
 2305 0ac8 EE24      		clr r14
 2306 0aca E394      		inc r14
 2307 0acc F12C      		mov r15,__zero_reg__
 2308               	.LVL255:
 2309 0ace EC0E      		add r14,r28
 2310 0ad0 FD1E      		adc r15,r29
1019:stk500boot.c  **** 			while ( msgLength )
 2311               		.loc 1 1019 0
 2312 0ad2 C85D      		subi r28,lo8(-296)
 2313 0ad4 DE4F      		sbci r29,hi8(-296)
 2314 0ad6 2881      		ld r18,Y
 2315 0ad8 C852      		subi r28,lo8(296)
 2316 0ada D140      		sbci r29,hi8(296)
 2317 0adc C75D      		subi r28,lo8(-297)
 2318 0ade DE4F      		sbci r29,hi8(-297)
 2319 0ae0 3881      		ld r19,Y
 2320 0ae2 C952      		subi r28,lo8(297)
 2321 0ae4 D140      		sbci r29,hi8(297)
 2322 0ae6 C65D      		subi r28,lo8(-298)
 2323 0ae8 DE4F      		sbci r29,hi8(-298)
 2324 0aea 4881      		ld r20,Y
 2325 0aec CA52      		subi r28,lo8(298)
 2326 0aee D140      		sbci r29,hi8(298)
 2327 0af0 C55D      		subi r28,lo8(-299)
 2328 0af2 DE4F      		sbci r29,hi8(-299)
 2329 0af4 5881      		ld r21,Y
 2330 0af6 CB52      		subi r28,lo8(299)
 2331 0af8 D140      		sbci r29,hi8(299)
 2332 0afa 00C0      		rjmp .L98
 2333               	.LVL256:
 2334               	.L99:
1020:stk500boot.c  **** 			{
1021:stk500boot.c  **** 				c	=	*p++;
 2335               		.loc 1 1021 0
 2336 0afc F701      		movw r30,r14
 2337 0afe 6190      		ld r6,Z+
 2338 0b00 7F01      		movw r14,r30
 2339               	.LVL257:
1022:stk500boot.c  **** 				sendchar(c);
 2340               		.loc 1 1022 0
 2341 0b02 862D      		mov r24,r6
 2342 0b04 C85D      		subi r28,lo8(-296)
 2343 0b06 DE4F      		sbci r29,hi8(-296)
 2344 0b08 2883      		st Y,r18
 2345 0b0a C852      		subi r28,lo8(296)
 2346 0b0c D140      		sbci r29,hi8(296)
 2347 0b0e C75D      		subi r28,lo8(-297)
 2348 0b10 DE4F      		sbci r29,hi8(-297)
 2349 0b12 3883      		st Y,r19
 2350 0b14 C952      		subi r28,lo8(297)
 2351 0b16 D140      		sbci r29,hi8(297)
 2352 0b18 C65D      		subi r28,lo8(-298)
 2353 0b1a DE4F      		sbci r29,hi8(-298)
 2354 0b1c 4883      		st Y,r20
 2355 0b1e CA52      		subi r28,lo8(298)
 2356 0b20 D140      		sbci r29,hi8(298)
 2357 0b22 C55D      		subi r28,lo8(-299)
 2358 0b24 DE4F      		sbci r29,hi8(-299)
 2359 0b26 5883      		st Y,r21
 2360 0b28 CB52      		subi r28,lo8(299)
 2361 0b2a D140      		sbci r29,hi8(299)
 2362 0b2c 0E94 0000 		call sendchar
 2363               	.LVL258:
1023:stk500boot.c  **** 				checksum ^=c;
 2364               		.loc 1 1023 0
 2365 0b30 7624      		eor r7,r6
 2366               	.LVL259:
 2367 0b32 C55D      		subi r28,lo8(-299)
 2368 0b34 DE4F      		sbci r29,hi8(-299)
 2369 0b36 5881      		ld r21,Y
 2370 0b38 CB52      		subi r28,lo8(299)
 2371 0b3a D140      		sbci r29,hi8(299)
 2372 0b3c C65D      		subi r28,lo8(-298)
 2373 0b3e DE4F      		sbci r29,hi8(-298)
 2374 0b40 4881      		ld r20,Y
 2375 0b42 CA52      		subi r28,lo8(298)
 2376 0b44 D140      		sbci r29,hi8(298)
 2377 0b46 C75D      		subi r28,lo8(-297)
 2378 0b48 DE4F      		sbci r29,hi8(-297)
 2379 0b4a 3881      		ld r19,Y
 2380 0b4c C952      		subi r28,lo8(297)
 2381 0b4e D140      		sbci r29,hi8(297)
 2382 0b50 C85D      		subi r28,lo8(-296)
 2383 0b52 DE4F      		sbci r29,hi8(-296)
 2384 0b54 2881      		ld r18,Y
 2385 0b56 C852      		subi r28,lo8(296)
 2386 0b58 D140      		sbci r29,hi8(296)
 2387               	.LVL260:
 2388               	.L98:
1019:stk500boot.c  **** 			while ( msgLength )
 2389               		.loc 1 1019 0 discriminator 1
 2390 0b5a EC14      		cp r14,r12
 2391 0b5c FD04      		cpc r15,r13
 2392 0b5e 01F4      		brne .L99
1024:stk500boot.c  **** 				msgLength--;
1025:stk500boot.c  **** 			}
1026:stk500boot.c  **** 			sendchar(checksum);
 2393               		.loc 1 1026 0
 2394 0b60 872D      		mov r24,r7
 2395 0b62 C85D      		subi r28,lo8(-296)
 2396 0b64 DE4F      		sbci r29,hi8(-296)
 2397 0b66 2883      		st Y,r18
 2398 0b68 C852      		subi r28,lo8(296)
 2399 0b6a D140      		sbci r29,hi8(296)
 2400 0b6c C75D      		subi r28,lo8(-297)
 2401 0b6e DE4F      		sbci r29,hi8(-297)
 2402 0b70 3883      		st Y,r19
 2403 0b72 C952      		subi r28,lo8(297)
 2404 0b74 D140      		sbci r29,hi8(297)
 2405 0b76 C65D      		subi r28,lo8(-298)
 2406 0b78 DE4F      		sbci r29,hi8(-298)
 2407 0b7a 4883      		st Y,r20
 2408 0b7c CA52      		subi r28,lo8(298)
 2409 0b7e D140      		sbci r29,hi8(298)
 2410 0b80 C55D      		subi r28,lo8(-299)
 2411 0b82 DE4F      		sbci r29,hi8(-299)
 2412 0b84 5883      		st Y,r21
 2413 0b86 CB52      		subi r28,lo8(299)
 2414 0b88 D140      		sbci r29,hi8(299)
 2415 0b8a 0E94 0000 		call sendchar
 2416               	.LVL261:
1027:stk500boot.c  **** 			seqNum++;
 2417               		.loc 1 1027 0
 2418 0b8e 1F5F      		subi r17,lo8(-(1))
 2419               	.LVL262:
 2420 0b90 A0E0      		ldi r26,0
 2421 0b92 B0E0      		ldi r27,0
 586:stk500boot.c  **** 		while (!isLeave)
 2422               		.loc 1 586 0
 2423 0b94 C85D      		subi r28,lo8(-296)
 2424 0b96 DE4F      		sbci r29,hi8(-296)
 2425 0b98 2881      		ld r18,Y
 2426 0b9a C852      		subi r28,lo8(296)
 2427 0b9c D140      		sbci r29,hi8(296)
 2428 0b9e C75D      		subi r28,lo8(-297)
 2429 0ba0 DE4F      		sbci r29,hi8(-297)
 2430 0ba2 3881      		ld r19,Y
 2431 0ba4 C952      		subi r28,lo8(297)
 2432 0ba6 D140      		sbci r29,hi8(297)
 2433 0ba8 C65D      		subi r28,lo8(-298)
 2434 0baa DE4F      		sbci r29,hi8(-298)
 2435 0bac 4881      		ld r20,Y
 2436 0bae CA52      		subi r28,lo8(298)
 2437 0bb0 D140      		sbci r29,hi8(298)
 2438 0bb2 C55D      		subi r28,lo8(-299)
 2439 0bb4 DE4F      		sbci r29,hi8(-299)
 2440 0bb6 5881      		ld r21,Y
 2441 0bb8 CB52      		subi r28,lo8(299)
 2442 0bba D140      		sbci r29,hi8(299)
 2443 0bbc 0023      		tst r16
 2444 0bbe 01F0      		breq .L32
 2445 0bc0 00C0      		rjmp .L33
 2446               	.LVL263:
 2447               	.L102:
 583:stk500boot.c  **** 	if (boot_state==1)
 2448               		.loc 1 583 0
 2449 0bc2 12E0      		ldi r17,lo8(2)
 2450 0bc4 212C      		mov r2,__zero_reg__
 2451 0bc6 312C      		mov r3,__zero_reg__
 2452 0bc8 812C      		mov r8,__zero_reg__
 2453 0bca 912C      		mov r9,__zero_reg__
 2454 0bcc 5401      		movw r10,r8
 2455 0bce 20E0      		ldi r18,0
 2456 0bd0 30E0      		ldi r19,0
 2457 0bd2 A901      		movw r20,r18
 2458               	.LBB103:
 2459               	.LBB80:
 2460               	.LBB78:
 2461               	.LBB77:
 446:stk500boot.c  **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 2462               		.loc 1 446 0
 2463               	/* #APP */
 2464               	 ;  446 "stk500boot.c" 1
 2465 0bd4 ABBE      		out 59, r10
 2466 0bd6 F401      		movw r30, r8
 2467 0bd8 6791      		elpm r22, Z+
 2468 0bda 7691      		elpm r23, Z
 2469               		
 2470               	 ;  0 "" 2
 2471               	/* #NOAPP */
 2472 0bdc CC5D      		subi r28,lo8(-292)
 2473 0bde DE4F      		sbci r29,hi8(-292)
 2474 0be0 7983      		std Y+1,r23
 2475 0be2 6883      		st Y,r22
 2476 0be4 C452      		subi r28,lo8(292)
 2477 0be6 D140      		sbci r29,hi8(292)
 2478               	.LVL264:
 2479               	.L32:
 2480               	.LBE77:
 2481               	.LBE78:
 2482               	.LBE80:
 2483               	.LBE103:
 492:stk500boot.c  **** 	boot_timer	=	0;
 2484               		.loc 1 492 0 discriminator 1
 2485 0be8 60E0      		ldi r22,0
 2486 0bea 70E0      		ldi r23,0
 2487 0bec 80E0      		ldi r24,0
 2488 0bee 00C0      		rjmp .L100
 2489               	.LVL265:
 2490               	.L33:
1028:stk500boot.c  **** 
1029:stk500boot.c  **** 
1030:stk500boot.c  **** 		}
1031:stk500boot.c  **** 	}
1032:stk500boot.c  **** 
1033:stk500boot.c  **** 
1034:stk500boot.c  **** 
1035:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
1036:stk500boot.c  **** 	sendchar('j');
1037:stk500boot.c  **** 	//	sendchar('u');
1038:stk500boot.c  **** 	//	sendchar('m');
1039:stk500boot.c  **** 	//	sendchar('p');
1040:stk500boot.c  **** 	//	sendchar(' ');
1041:stk500boot.c  **** 	//	sendchar('u');
1042:stk500boot.c  **** 	//	sendchar('s');
1043:stk500boot.c  **** 	//	sendchar('r');
1044:stk500boot.c  **** 	sendchar(0x0d);
1045:stk500boot.c  **** 	sendchar(0x0a);
1046:stk500boot.c  **** 
1047:stk500boot.c  **** 	delay_ms(100);
1048:stk500boot.c  **** #endif
1049:stk500boot.c  **** 
1050:stk500boot.c  **** 
1051:stk500boot.c  **** 
1052:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 2491               		.loc 1 1052 0
 2492               	/* #APP */
 2493               	 ;  1052 "stk500boot.c" 1
 2494 0bf0 0000      		nop
 2495               	 ;  0 "" 2
1053:stk500boot.c  **** 
1054:stk500boot.c  **** 	/*
1055:stk500boot.c  **** 	 * Now leave bootloader
1056:stk500boot.c  **** 	 */
1057:stk500boot.c  **** 
1058:stk500boot.c  **** 	UART_STATUS_REG	&=	0xfd;
 2496               		.loc 1 1058 0
 2497               	/* #NOAPP */
 2498 0bf2 8091 C000 		lds r24,192
 2499 0bf6 8D7F      		andi r24,lo8(-3)
 2500 0bf8 8093 C000 		sts 192,r24
1059:stk500boot.c  **** 	boot_rww_enable();				// enable application section
 2501               		.loc 1 1059 0
 2502 0bfc 81E1      		ldi r24,lo8(17)
 2503               	/* #APP */
 2504               	 ;  1059 "stk500boot.c" 1
 2505 0bfe 8093 5700 		sts 87, r24
 2506 0c02 E895      		spm
 2507               		
 2508               	 ;  0 "" 2
1060:stk500boot.c  **** 
1061:stk500boot.c  **** 
1062:stk500boot.c  **** 	asm volatile(
 2509               		.loc 1 1062 0
 2510               	 ;  1062 "stk500boot.c" 1
 2511 0c04 EE27      		clr	r30		
 2512 0c06 FF27      		clr	r31		
 2513 0c08 0994      		ijmp	
 2514               		
 2515               	 ;  0 "" 2
 2516               	/* #NOAPP */
 2517               	.L101:
 2518 0c0a 00C0      		rjmp .L101
 2519               	.LVL266:
 2520               	.L105:
 611:stk500boot.c  **** 						checksum		=	MESSAGE_START^0;
 2521               		.loc 1 611 0
 2522 0c0c 8BE1      		ldi r24,lo8(27)
 2523 0c0e 782E      		mov r7,r24
 610:stk500boot.c  **** 						msgParseState	=	ST_GET_SEQ_NUM;
 2524               		.loc 1 610 0
 2525 0c10 81E0      		ldi r24,lo8(1)
 2526 0c12 00C0      		rjmp .L66
 2527               	.LVL267:
 2528               	.L108:
 658:stk500boot.c  **** 						msgParseState	=	ST_GET_CHECK;
 2529               		.loc 1 658 0
 2530 0c14 86E0      		ldi r24,lo8(6)
 2531 0c16 00C0      		rjmp .L66
 2532               	.LVL268:
 2533               	.L109:
 669:stk500boot.c  **** 						msgParseState	=	ST_START;
 2534               		.loc 1 669 0
 2535 0c18 80E0      		ldi r24,0
 2536               	.LVL269:
 2537 0c1a 00C0      		rjmp .L66
 2538               	.LFE19:
 2540               		.section	.rodata
 2543               	CSWTCH.21:
 2544 0000 0F        		.byte	15
 2545 0001 02        		.byte	2
 2546 0002 0A        		.byte	10
 2549               	speedoino_data:
 2550 0003 F8        		.byte	-8
 2551 0004 80        		.byte	-128
 2552 0005 E0        		.byte	-32
 2553 0006 80        		.byte	-128
 2554 0007 80        		.byte	-128
 2555 0008 F8        		.byte	-8
 2556 0009 F0        		.byte	-16
 2557 000a 88        		.byte	-120
 2558 000b 88        		.byte	-120
 2559 000c 88        		.byte	-120
 2560 000d 88        		.byte	-120
 2561 000e F0        		.byte	-16
 2562 000f F8        		.byte	-8
 2563 0010 20        		.byte	32
 2564 0011 20        		.byte	32
 2565 0012 20        		.byte	32
 2566 0013 20        		.byte	32
 2567 0014 F8        		.byte	-8
 2568 0015 88        		.byte	-120
 2569 0016 C8        		.byte	-56
 2570 0017 A8        		.byte	-88
 2571 0018 98        		.byte	-104
 2572 0019 88        		.byte	-120
 2573 001a 88        		.byte	-120
 2574 001b F8        		.byte	-8
 2575 001c 88        		.byte	-120
 2576 001d 88        		.byte	-120
 2577 001e 88        		.byte	-120
 2578 001f 88        		.byte	-120
 2579 0020 F8        		.byte	-8
 2580 0021 F8        		.byte	-8
 2581 0022 80        		.byte	-128
 2582 0023 F8        		.byte	-8
 2583 0024 08        		.byte	8
 2584 0025 08        		.byte	8
 2585 0026 F8        		.byte	-8
 2586 0027 F0        		.byte	-16
 2587 0028 88        		.byte	-120
 2588 0029 F8        		.byte	-8
 2589 002a 80        		.byte	-128
 2590 002b 80        		.byte	-128
 2591 002c 80        		.byte	-128
 2706               	.Letext0:
 2707               		.file 3 "/usr/lib/gcc/avr/4.7.0/../../../avr/include/stdint.h"
 2708               		.file 4 "logo.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 stk500boot.c
     /tmp/cc1vhP3Z.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc1vhP3Z.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc1vhP3Z.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc1vhP3Z.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/cc1vhP3Z.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc1vhP3Z.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc1vhP3Z.s:11     .text:0000000000000000 sendchar
     /tmp/cc1vhP3Z.s:36     .text:0000000000000018 senden_spi
     /tmp/cc1vhP3Z.s:80     .text:000000000000003a send_command
     /tmp/cc1vhP3Z.s:99     .text:0000000000000044 send_char
     /tmp/cc1vhP3Z.s:116    .text.unlikely:0000000000000000 draw_line.constprop.0
     /tmp/cc1vhP3Z.s:176    .init9:0000000000000000 __jumpMain
     /tmp/cc1vhP3Z.s:186    *ABS*:00000000000021ff __stack
     /tmp/cc1vhP3Z.s:267    .text.startup:0000000000000000 main
     /tmp/cc1vhP3Z.s:224    .text:000000000000004a delay_ms
     /tmp/cc1vhP3Z.s:2549   .rodata:0000000000000003 speedoino_data
     /tmp/cc1vhP3Z.s:2543   .rodata:0000000000000000 CSWTCH.21

UNDEFINED SYMBOLS
__muluhisi3
__udivmodsi4
__do_copy_data
